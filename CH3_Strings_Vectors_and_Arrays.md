C++ 除了定义了各种内置类型，还定义了很多实用抽象数据类型以及与之相关的类型如：迭代器（iterator）和大小（size_type）。本章将描述 string 和 vector 类型。string 支持可变长度字符串，vector 支持可变长度的集合。两者都定义了迭代器类型来遍历其中的元素，这个功能类似于 C++ 内置的指针类型。string 本身则是对 C 风格字符串的简化和模拟，vector 则是对数组的简化和抽象。

内置类型是对硬件的较低抽象，当需要操作底层时很方便使用。而对于大型项目来说就显得抽象程度太低了，因而，C++ 的标准库定义了很多实用的更高抽象的数据类型来提高大型项目的开发效率。

本章还将介绍数组，特别是数组与指针之间的关系，这一部分将使用的《C 语言编程》中的内容。数组亦是对硬件的较低抽象，就其灵活性而言将无法媲美 vector 类型。

## 3.1 名称空间的 using 声明

using 声明的格式 `using namespace::name;` 使得在程序中不再需要名称空间前缀就可以直接访问名字。不要在程序中滥用此特性，会引起名字冲突。即便是使用了 using 声明，也可以用全限定的方式引用名字，确保使用是我们想要的名字。必须为每个希望直接使用的名字加上 using 声明，并且用分号结尾。并且不能在头文件中加入 using 声明，这将会导致所有包含的源文件中都有此 using 声明，冲突的危险将加大。

## 3.2 string 类型

string 表示可变长度的字符串。string 类型包含在 `<string>` 头文件中。std::string 类型被标准库的实现者实现的性能足够好，因而可以适用于绝大多数场景。我们应该记住很重要的一点：相对于内置类型并不总是初始化，所有的类类型都会调用类自己构造函数进行初始化。一个类会定义多个构造函数来执行初始化。以下是最基本的 string 的构造函数：

- `string s1` 默认初始化，s1 是空字符串；
- `string s2(s1)` 将 s2 初始化为 s1 的副本；
- `string s2 = s1` 与 `s2(s1)` 一样；
- `string s3("value")` s3 是字符串字面量，不包括末尾的 `\0` 字符；
- `string s3 = "value"` 与 `s3("value")` 相同；
- `string s4(n, 'c')` 将 s4 初始化为 n 个字符 c ；

在上面的构造函数中有两种不同的形式：复制初始化（copy initialize）是以等号形式将右边的初始值复制到左边的对象中去。这里 `"value"` 并不是 string 类型，这种方式其实是构造了一个 string 临时对象并以此临时对象代替了 s3，如果考察 `string str = string("value")` 就会更清楚，因为这个语句跟 `s3 = "value"` 的调用过程是一模一样的。其实这里边的复制过程被优化掉了，而 `s2 = s1` 则执行了复制构造函数，其原因在于 s1 的内存已经被分配个了另一个对象，不能直接替换，相反临时对象可以替换。还有一种初始化形式即直接初始化（direct initialization）。

当只有一个初始值时使用直接初始化和拷贝初始化的效果是一样的。当有多个参数时只能使用直接初始化，或者用 `string s8 = string(10, 'c');` 的形式先创建一个临时对象再执行拷贝初始化，这里同样是直接将临时对象替换过去的，因为临时对象在声明语句后消失，因而可以安全替换。

### 3.2.2 string 可执行的操作

类除了定义了如何创建和初始化之外还定义了可以执行哪些操作。C++ 中的类既可以定义按名字调用的成员函数，也可以对操作符进行重载，事实上在 C++ 中操作符是一种特殊的函数。Lua 中提供了元表以及元方法跟 C++ 的操作符重载非常类似。如以下列出最常用的几个 string 类方法：

- `os << s` 将字符串 s 写入到流 os 中，返回 os ；