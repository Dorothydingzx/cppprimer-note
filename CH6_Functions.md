函数（function）是具名的计算单元（named compute unit），在 C 和 C++ 中与子程序（subroutine）是不加区别的，指的就是执行特定任务的程序指令，它们被打包成一个单元。函数可以用在此任务需要执行的任何地方。

函数可以定义在程序中或者分离定义在库（library）中（定义在库中的代码可以被多个程序复用）。在不同的编程语言中，它具有不同的名字 —— 过程（procedure）、函数（function）、子程序（routine）、方法（method）、子程序（subprogram），以及更加通用的术语**调用单元**（callable unit）。

函数可以在程序的一次执行中从多个不同的地方以及多个不同的时间被调用（call），当计算完成时又返回到调用的下一条指令。Maurice Wilkes 等人称之为闭合子程序（closed subroutine）以区别于宏（macro）或者叫开放子程序（open subroutine），它们之间的区别在于函数有一个单独的作用域，调用时将实参进行求值然后初始化这个独立计算区域中的形参。而宏则是执行文本替换，实际上不存在调用的概念，将实参表达式替换每一个对应的形参，因而也会求值多次。只有闭合子程序才能支持递归调用。

函数的好处在于提高代码的密度（code density），复用代码可以有效的降低开发和维护大程序的成本，同时提高代码的质量和可靠性。面向对象编程（object-oriented programming）是建立在将函数与数据拼合在一起的原则上的。

从编译器的角度来看，程序就是一系列的函数的调用。

函数有两种功用，其一是数学函数（mathematical functions）的概念，就是纯计算，计算的结果完全由输入的参数决定，如：计算对数。其二是调用产生副作用（side effect）如：修改数据结构或者读写 I/O 设备，创建文件等。相同的参数在不同时期的调用结果很可能是不一样的，具体则依赖于当时的程序状态。

函数可以递归的调用的特性，使得可以直接将数学归纳（mathematical induction）和分治算法（divide and conquer algorithms）实现为程序代码。

## 6.1 函数基础

函数由返回类型、名字和形参（parameters）列表以及函数体构成。参数列表可能有一个或多个参数，也可能没有参数，参数之间用逗号分隔。函数的指令放在一个语句块中，被称为函数体（function body）。

执行函数用调用操作符（call operator），调用操作符是一对括号，调用操作符以函数或者函数指针为操作数，在括号则指定逗号分隔的实参（arguments），实参被用于初始化形参，初始化的过程与变量的初始化是一样的。调用表达式的类型是返回类型。

函数调用时将形参初始化为实参，并且将控制权转移到被调用的函数，此时调用函数（calling function）的执行被暂停，被调用函数（called function）开始执行。被调用函数执行的第一步是隐式定义并初始化参数。然后执行函数体。最后当函数遇到 return 语句或者执行到函数体尾部时自动返回控制权到调用函数，并且返回 return 语句中的值，这个值被用于初始化调用表达式的结果。

### 6.1.1 形参和实参

实参用于初始化形参，C++ 是按照参数顺序进行初始化的，并且不保证实参的求值顺序的。传入的参数必须与形参的类型匹配，并且个数也是必须一致的，因而，所有形参都保证一定会初始化。与初始化一样，允许从参数到形参的转换，只要这种转换是合法的。

C++ 中可以用一对空括号表示来表示没有参数，C 中早年必须在括号中写 void 来表示没有参数。如
````cpp
void f() {/*...*/}
void f(void) {/*...*/}
````
形参列表就是一系列用逗号分隔的变量声明，变量声明之间是独立的，因而，即便是类型相同的参数也需要重复书写类型名。没有形参的名字是一样的，函数体内的顶层作用域中的本地变量也不会与形参同名。这与同一作用域中不允许同名变量是一样的。

偶尔函数的参数不使用，这种参数可以不命名，即便此参数不命名，当调用时还是必须传入对应的参数。

### 6.1.2 返回类型

返回类型可以是除数组类型和函数类型外的任何类型，可以是 void 类型表示没有没有返回值。虽然不能返回数组和函数，但是可以返回数组的指针和引用，以及函数指针。

### 6.1.3 本地变量

C++ 中的名字有作用域和生命周期（lifetimes）。作用域是程序文本中哪些位置可以看到此名字。生命周期是对象在程序运行期间存活的时期。函数体是一个语句块，因而生成一个新的作用域。形参和在此作用域中定义的变量被称为本地变量（local variables），本地变量会隐藏外部定义的变量。定义在任何函数外的变量在程序的整个执行过程中都存在，这种变量当程序启动时创建，直到程序中止时销毁。

函数中有一种本地变量是自动对象（automatic objects），这种变量当函数控制通过此变量定义时创建，当离开定义变量的语句块时销毁。当离开语句块时，其中定义的自动对象值是未定义的。参数是自动对象，当函数开始时将分配内存给参数，当函数结束时销毁。自动对象中的函数参数被初始化为函数实参，自动对象中的本地变量被初始化为定义时给出的初始值，或者被默认初始化，意味着未初始化的内置类型对象具有未定义值。

将本地变量定义为 static 将得到一个本地静态对象（local static object），本地静态对象将在第一次遇到对象的定义时初始化，当函数结束时对象不会被销毁，只有当程序结束时才会销毁。在多次调用函数之间，变量的值沿用上次调用时的最终值。当本地静态对象没有显式初始化时，将执行值初始化，意味着内置类型的本地静态变量将被初始化为 0。

### 6.1.4 函数声明

函数在使用前必须先声明，这样函数才会可见。函数与变量一样只能定义一次，但是可以声明多次。一个函数可以在没有定义的情况下声明，但想要调用此函数必须得有定义才行。函数声明与函数定义一样除了没有函数体之外。函数声明可以省略参数的名字只留下类型。函数声明分为三个部分：返回类型、函数名字和参数类型，这是调用函数需要知道的全部信息，这个三个元素合起来称为函数原型（function prototype）。

函数声明最好是放在头文件中，以保证所有引入的地方都保持一致，改变声明也仅需改变一个地方。实现函数的源文件也需要包含函数声明，这样可以校验定义和声明是否一致。

### 6.1.5 分离编译（Separate Compilation）

随着程序不断变大，以及为了支持库的开发。C++ 提供了类似于 C 语言一样的分离编译机制。将程序分为逻辑上的多个部分并且允许将这些部分放到不同的文件中去单独编译。编译出来的文件为对象文件（obj file），当最终需要可执行文件时再链接（link）成可执行文件。由于支持单独编译，因而，当只改动了一个文件时，可以对那一个文件进行编译然后链接在一起形成可执行文件。

## 6.2 参数传递

每次调用函数时都会创建形参并且用实参值进行初始化。对形参的初始化与对普通变量初始化是一样的。如果形参是引用，那么形参就会被绑定到实参上，这种方式的传递称为按引用传递（passed by reference），此函数调用称为按引用调用（called by reference），因而引用形参就是实参的别名。形参不是引用时就会将实参拷贝到形参中，此时形参和实参是相互独立的对象，这种方式的传递称为按值传递（passed by value），此函数称为按值调用（called by value）。

### 6.2.1 按值传递

当按值传递时，对形参做出的任何改变都不会影响到实参造成任何影响。以指针为形参需要记住一点就是指针间接访问对象，所以可以通过指针来改变对象值，在直观上与按值传递是不一致的。C 程序员通常用指针来访问调用函数中的对象，C++ 程序员则更多使用引用来访问。

### 6.2.2 按引用传递

按引用传递的一个作用就是使得函数可以改变其实参。而且很多对象拷贝很耗时，甚至有对象是不允许拷贝的。如：I/O 类型对象就不允许拷贝。C++ 的原则是对于不想改变值的对象使用 const 引用作为形参。

C++ 的函数只能返回一个值，当需要返回多个值时，引用使得可以有效返回多个结果。

### 6.2.3 const 形参和实参

与变量初始化一样。当用形参去初始化实参时，顶层 const 将被忽略，所以形参的顶层 const 不影响怎样传递实参，我们可以传递 const 和非 const 对象给有顶层 const 的形参。如果重载的函数只是形参的顶层 const 修饰不一样，可以用相同的参数去调用这两个函数，编译器没有足够的信息来区分这两个函数。这种情况下将被认为是重复定义。如：
````cpp
void fcn(const int i) { /* ... */}
void fcn(int i) { /* ... */ } //error: 重复定义fcn
````
对于指针和引用的底层 const 修饰，与变量初始化一样，可以将非 const 对象用于初始化 const 对象，但不能执行相反的过程。对于非 const 引用，用于初始化的实参必须是相同类型的。所以这里有一个原则就是尽可能使用 const 引用，原因是非 const 引用导致函数只能接收类型精确匹配的左值对象，任何 const 对象、字面量或者需要转型的对象都被排除在外。除非是真正想要改变引用对应的实参值才会使用非 const 引用。

### 6.2.4 数组形参

数组是比较特殊的类型，原因在于数组不能够被复制，作为参数传递时数组会自动转换为指向头元素的指针。事实上即便是将形参形式写成数组的格式，接收的参数依然是指针。如：
````cpp
void print(const int*)
void print(const int[]);
void print(const int[10]);
````
以上三个函数是完全一样的，参数都是 `const int*`，注意最后一个带了函数的大小，但是这个值会被编译器完全忽略掉。事实上，如果给上面几个函数进行定义，编译器会认为是重复定义。而且用 sizeof 对这几个参数进行求大小得到的结果是指针的大小而不是数组的大小。程序员必须自己保证传入的数组不会越界，这需要接口实现者和调用者协调保证，语言本身不会提供任何保护机制，如果真的发生了数组越界结果将是未定义的。因而，这种函数常常会有第二参数来传入数组的长度。

有三种方式来定义数组的边界：其一是设置一个结束的标记，如：C 风格字符串末尾的空字符。其二是传入头指针和尾后指针。其三是 C 语言和旧式 C++ 程序最常用的方式：传入额外的 size 参数。

与引用参数一样，除非是希望改写数组中的元素，应该将参数定义为指向 const 对象的指针。

除了以上传入数组首元素指针的形式，可以定义数组引用的形参。此时，数组的大小将称为类型的一部分，因而函数内可以依赖于此大小。然而由于函数接口定死了数组大小也限制了数组的运用范围。如：
````cpp
void print(int (&arr)[10]);
````
以上函数必须将 & 号放在括号内部。

在第二章中介绍过多维数组，如果以多维数组作为参数传给函数，那么其实传的是指向二级数组的指针，并且子数组的长度是类型的一部分，因而必须指定其长度。如：
````cpp
void print(int(*matrix)[10], int rowSize) { /*...*/ }
````
以上部分中 * 号必须放在括号内部，表示指针的优先级高于数组。并且与以下定义完全一样：
````cpp
void print(int matrix[][10], int rowSize) { /*...*/ }
````
数组形式的参数与指针形式的参数是完全一致的。

### 6.2.5 main：处理命令行参数

C++ 程序允许从命令行传递选项到程序中去。方式是定义 main 函数是指定两个额外的参数。以下为其形式：
````cpp
int main(int argc, char *argv[]) { /*...*/ }
````
其中第一个参数是选项的个数，第二个参数是指针数组，其中每个指针指向一个表示选项的 C 风格字符串。以下函数定义是完全一样的，将 argv 定义指向 `char*` 的指针。
````cpp
int main(int argc, char **argv) { /*...*/ }
````
main 函数中 argv 指向的第一个元素是函数的名字或者空字符串，真正的选项是从 1 号位开始的。尾后元素被保证是空指针。如：
````cpp
//prog -d -o ofile data0
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
````

### 6.2.6 不定形参

当不确定参数有多少个以及这些参数是什么类型时，需要用到不定形参。其实除了参数不一样外，行为都是一样的，重载多个函数完全不现实。C++ 中逐渐遗弃了 C 风格的省略号形参（Ellipsis Parameters），转而使用两种类型校验更强的方式。如果参数的类型是一样的，那么可以使用类 `initializer_list` ，如果类型都不一样那么使用可变参数模板（variadic template）。而省略号形式的不定形参被建议仅用于提供给 C 函数的接口。

`initializer_list` 是一个类模板，表示某种类型的数组，被定义在头文件 `initializer_list` 头文件中。以下简单列举此类对象可以执行的操作：

- `initializer_list<T> lst;` 包含元素类型 T 的空列表；
- `initializer_list<T> lst{a,b,c...};` 将初始化列表中的值拷贝到列表中，最终列表中的值是 const 的；
- `lst2(lst)` `lst2 = lst` 这种形式的初始化或赋值不会拷贝元素，而是共享相同的元素；
- `lst.size()` 返回列表的元素个数；
- `lst.begin()` `lst.end()` 返回头元素和尾后元素的迭代器；

需要记住的是 `initializer_list` 中的元素总是 const 的，不能改变其中元素的值。当传递给函数 `initializer_list` 参数时需要将序列放在大括弧中。如：
````cpp
void error_msg(initializer_list<string> il);
error_msg({"functionX", "okay", "expected", "actual"});
````
省略号形如：`void foo(parm_list, ...);` ，其中省略号只能出现在参数列表的末尾。其中 `parm_list`后的逗号可以省略，但最好不要这样做以免引起歧义。有几个函数来帮助访问省略号形式的可变参数（variadic arguments）。

- `va_start` 使得可以开始访问可变参数；
- `va_arg` 访问下一个可变参数；
- `va_list` 保存供 `va_start` `va_arg` `va_end` 访问的信息，必须首先调用；
- `va_end` 结束访问可变参数；

````cpp
#include <iostream>
#include <cstdarg>
 
//其 fmt 后省略了逗号
void simple_printf(const char* fmt...)
{
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0') {
        if (*fmt == 'd') {
            int i = va_arg(args, int);
            std::cout << i << '\n';
        } else if (*fmt == 'c') {
            // note automatic conversion to integral type
            int c = va_arg(args, int);
            std::cout << static_cast<char>(c) << '\n';
        } else if (*fmt == 'f') {
            double d = va_arg(args, double);
            std::cout << d << '\n';
        }
        ++fmt;
    }
 
    va_end(args);
}
 
int main()
{
    simple_printf("dcff", 3, 'a', 1.999, 42.5); 
}
````
在 C++ 中省略号形式的参数中如果有类类型，很可能不能正确的进行拷贝。并且省略号形式的参数是不做类型检查的。在 C 语言中要求在省略号前必须要有一个具名形参（named parameter），C++ 中如果没有具名参数虽然是合法的，但是无法访问可变参数。

## 6.3 返回类型和 return 语句

return 语句将终止函数的执行并返回控制权到函数调用点，将立即执行调用点之后的代码，这个地方叫做返回地址（return address），返回地址在执行调用时被保存在调用栈上。C++ 语言 return 语句返回一个返回值（return value）给调用者，而一些语言则没有提供返回值的语言特性，它们转而提供了出参数（output parameter），还有另外一些语言则默认函数的最后一条语句是函数的返回值，如：scala 。

当函数执行到最后一条语句时会自动返回。曾经有争议是否应当在函数的中间返回（称为早期退出 “early exit”），支持的观点有证据显示从中间返回使得程序员书写起来更不易出错，也更容易理解。而反对观点则认为中间返回将导致资源得不到有效释放，而从函数的底部退出就不会跳过释放的代码。C++ 通过在栈展开（stack unwinding）时由对象释放的析构函数自动调用进行资源释放，这种方式也被称为 RAII（resource acquisition is initialization）资源获取即初始化，很多人认为这是一个非常糟糕的术语用于描述对 C++ 来说几乎是最重要的概念，有人甚至认为应当用 DIRR （Destruction is Resource Relinquishment）析构即资源释放，或者叫 SBRM（Scope Bound Resource Management）局部绑定资源管理。

有两种形式进行函数返回：
````cpp
return;
return expression;
````

### 6.3.1 函数没有返回值

如以下例子：
````cpp
void swap(int &v1, int &v2)
{
    if (v1 == v2)
        return;
    int tmp = v2;
    v2 = v1;
    v1 = tmp;
}
````

没有返回值的函数的返回类型被定义为 void，其可以在函数中间用 `return;` 语句返回，这个 return 后是不带返回值的。如果返回了任何值便是编译错误，对于有返回值的函数也是一样的，如果返回的类型不一致并且无法转换便是编译错误。

如果没有返回语句，函数将在最后一条语句隐式返回。

void 返回类型函数可以用第二种形式的返回，但需要保证 expression 是对一个返回 void 类型的函数的调用，返回其它类型的表达式是编译时错误。

### 6.3.2 函数有返回值
### 6.3.3 函数返回指向数组的指针
## 6.4 函数重载（Overloaded Functions）
### 6.4.1 重载和作用域
## 6.5 C++ 函数专用特性
### 6.5.1 默认实参（Default Arguments）
### 6.5.2 内联函数和 constexpr 函数
### 6.5.3 Debugging 辅助特性
## 6.6 函数调用匹配
### 6.6.1 实参类型转换
## 6.7 函数指
## 关键术语