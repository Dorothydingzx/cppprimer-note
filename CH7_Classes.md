C++ 中最重要的特性之一就是类，通过类可以有效表达代解决的问题中的概念。类讲求数据抽象（data abstraction），即是将类的实现与类所能表达的功能分离开来。类背后的哲学就是数据抽象和封装（encapsulation）。

数据抽象意在将不必要的细节剥离出来以期更加接近问题的本质特性。数据抽象往往是设计系统的第一步，原因在于完整的系统非常复杂，几乎不能在没有一个简单抽象的情况下一步完成。数据抽象使得可以从最本质的特性开始然后一步步丰富到最终的系统。有一些别的术语与此相近，比如：建模（modeling）、泛化（generalization）。抽象是设计一些软件的开端，亦是最重要的武器。

封装则是两个相关但不同概念的组合：将对象状态隐藏使得外部无法直接访问；将数据和方法打包到一起；在一些语言中隐藏组件不是自动发生的，甚至不可能隐藏，因而，在这些语言中只有第二种含义。而第一种含义有另外一个术语表示：信息隐藏（information hiding）。

类使用数据抽象和封装来定义抽象数据类型（abstract data type，ADT），抽象数据类型使得可以以抽象的方式来思考，即仅需要知道类可以做什么，而不必深究类是怎么做到的，这些实现的细节留给设计者去考虑。

## 7.1 定义抽象数据类型

只有具有行为或者说接口的类型才能称为数据类型，如果只有数据而没有行为，所有行为都需要用户自行编写，那便不能称为抽象的数据类型。“行为”的含义了抽象机器的公理语义（axiomatic semantics）和操作语义（operational semantics），有些语境下还会包含计算复杂度（computational complexity）包括时间复杂度和空间复杂度。现实中的很多数据类型不是完美的抽象数据类型，原因在于机器现实，如：算数溢出等。抽象数据类型是计算机科学中的理论概念，不对应于任何特定的语言特性。这个概念被运用于设计和分析算法，数据结构和软件系统。许多概念类似于抽象数据类型：抽象类型（abstract types）、透传数据类型（opaque data types）、协议（protocols）和按约定设计（design by contract）。

[https://en.wikipedia.org/wiki/Abstract_data_type](https://en.wikipedia.org/wiki/Abstract_data_type)

### 7.1.1 设计类

设计类时需要分清楚两种不同的编程角色：设计者和用户。类的设计者负责设计接口和实现。用户则负责使用这些接口完成别的任务。不论在任何时候都需要清楚分离设计者和用户角色，这样能够很好的解耦从而使得程序演变更加容易。在一些简单的应用中，常常类的用户和设计者时同一个人，作为设计者应该努力思考让类更加容易使用，从而使得用户必须了解类的实现就能够很好使用类。设计良好的类通常接口时直观且易用的，并且实现地足够高效。

### 7.1.2 定义类

类中有一些函数是实现的一部分，这些函数不会作为接口的一部分，这些函数需要被定义为私有的。C++ 中会包含一些作为接口的非成员函数，这些函数将定义在类的外部。定义和声明成员函数（member functions）于普通函数类型，成员函数必须在类中声明，定义在类内或者类外。定义在类内的函数隐式称为内联函数。

示例代码：[use_sales_data.cc](https://github.com/chuenlungwang/cppprimer-note/blob/master/code/use_sales_data.cc)

当调用一个对象的成员函数时，所有操作都作用在此对象上。如：
````cpp
string isbn() const { return bookNo; }
````
当调用 `total.isbn()` 时，返回的是 `total.bookNo`，成员函数通过一个额外的隐式参数 this 来访问调用对象。this 被默认初始化为函数调用对象的地址。此处 this 是 total 对象的地址。就如以下代码：`isbn(&total)`

在成员函数内可以直接使用成员名字而不需要使用成员访问符去访问，这种直接使用成员名字会被编译器隐式转换为 `this->bookNo` 形式。

this 参数由编译器隐式定义，并且不允许程序员定义参数或者变量名为 this ，this 总是指向当前调用的对象，所以，this 是一个 const 指针，我们不能改变 this 使其指向别的对象。

参数列表后的 const 用来说明 this 指针指向 const 对象。通常情况下 this 是指向非 const 对象的 const 指针，尽管 this 是隐式定义的，它也遵循初始化原则，即不能将非 const 的 this 指向 const 对象，从而不能在 const 对象上调用非 const 的函数。为了在 const 对象上调用成员函数，必须使得 this 指向 const 对象，如果 this 指针可以在参数列表中，那么它将形如：`const Sales_data *const` ，然而 this 是隐式定义的并且不可能出现在参数列表中，所以语言通过在参数列表后放置 const 来表明 this 指针指向 const 对象，从而使得此成员函数称为 const 成员函数。isbn 函数可以描述为：
````cpp
string Sales_data::isbn(const Sales_data *const this)
{ return this->isbn; }
````
this 指针指向 const 对象，说明 const 成员函数不能改变调用对象的状态。const 对象、指向 const 对象的指针和绑定 const 对象的引用只能调用 const 成员函数。

**类作用域和成员函数**

类本身就是一个作用域，所以，成员函数的定义处于类作用域中，因而，当 isbn 不加任何限定符使用 bookNo 时，将被解析为使用 Sales_data 中的 isbn。值得注意的是这种使用甚至可以在 bookNo 的定义之前。编译器处理类是分两步走的：成员定义先处理，然后才是成员函数体。因此，成员函数可以使用其它成员而不必纠结它们出现的顺序。

**在类外部定义成员函数**

与任何别的函数一样，当在类外部定义成员函数时需要定义与声明完全一致。特别是参数列表后的 const 需要一致。除此之外，在类外定义的成员名字必须用类名加以限定。如：
````cpp
double Sales_data::avg_price() const {
    if (units_sold)
        return revenue/units_sold;
    else
        return 0;
}
````
Sales_data::avg_price 的含义就是说函数名字 avg_price 是声明在作用域 Sales_data 类中的。一旦编译器看到函数名字，剩下的代码将被解释为处于类作用域中。因而，revenue , units_sold 都是隐式解释为 Sales_data 的成员。

**定义函数返回“当前”对象**

成员函数返回当前调用对象的关键在于设置返回类型和书写返回语句。返回当前对象意味着需要返回当前对象的引用，而且需要在返回时对 this 进行解引用。如：
````cpp
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
````
调用 `total.combine(trans);` 将返回 total 对象的引用。

### 7.1.3 定义类相关的非成员函数

类作者可以定义一些辅助函数，这些函数定义的操作在概念上属于类接口的一部分，但是本身不在类内。这些函数通常与类定义在同一个头文件中，使得用户只需要包含一个文件就可能够使用与类相关的任何接口部分。这些函数与普通的函数并没有什么区别，它们并不在类的作用域内，因而，没有隐式的 this 指针以及不能直接使用成员，甚至调用时是直接写出函数名，而不是由对象进行调用。

### 7.1.4 构造函数

每个类都定义该类的对象如何进行初始化，类通过定义一个或者多个特殊成员函数来控制初始化，称为构造函数（constructors）。构造函数的工作就是初始化类的数据成员，每当对象创建时构造函数就会调用。

构造函数和类的初始化是很复杂的，有一个总原则就是初始化所有数据成员，而不是依赖于编译器设置默认值。原因在于，编译器在不同的情况下会不会设置默认值是不一样的，而记住所有不同情况下的行为是很累人的。这些复杂的初始化参考：[https://en.cppreference.com/w/cpp/language/initialization](https://en.cppreference.com/w/cpp/language/initialization) 中值初始化（value initialization）、默认初始化（default initialization）和零初始化（zero initialization）。

构造函数与类名相同而且没有返回值，除此之外与常规函数没有别样。构造函数与常规函数一样可以进行重载。构造函数不能被声明为 const 的，原因在于即便是 const 对象亦需要在构造函数完成初始化之后才能变成常量。

**合成默认构造函数**

当定义对象时不给定初始值将执行默认初始化。类控制默认初始化的构造函数称为默认构造函数（default constructo），这个构造函数是没有任何参数的构造函数。其特殊性在于如果类没有显式定义任何构造函数，编译器会隐式定义一个默认构造函数，这个生成的默认构造函数称为合成默认构造函数（synthesized default constructor）。合成构造函数初始化每个数据成员的方式是：

- 如果有类内初始值，就用那个初始值进行初始化；
- 没有，则使用默认初始化，对于类成员将调用其默认构造函数，对于内置类型则不进行任何初始化；

事实上，默认初始化远远比上面提到的两句话要复杂。在 [Initialization in C++ is bonkers](https://blog.tartanllama.xyz/initialization-is-bonkers/) 一文中做出了详尽的解释，是目前阅读过的最好的一篇关于初始化的文章。如果要更加理解初始化过程中的内容，建议阅读 C++ 标准中相关章节。

**一些类不能依赖于合成默认构造函数**

只有十分简单的类可以依赖于合成的默认构造函数。最常见的原因在于编译器只在程序员没有为此类定义任何构造函数时才会生成。如果定义了任何构造函数，将必须手动定义默认构造函数，编译器不会再协助生成了。原因在于编译器认为如果程序员在一种情形下控制了对象的初始化，多半会需要在所有情况下控制对象的初始化。

第二个原因是合成的构造函数不能达到预想的效果。内置类型和复合类型（数组、指针）作为类成员，在默认初始化时不做任何事情。所以，内置类型或复合类型的成员都应该在类内初始化或者定义自己的默认构造函数。只有当内置类型或复合类型有类内初始值时才能依赖于合成默认构造函数。

第三个原因是有些类编译器根本无法合成默认构造函数。原因在于，一个类可以有一个没有默认构造函数的类类型成员，那么编译器将无法初始化此成员。

** `=default` 的含义**
````cpp
struct Sales_data {
    Sales_data() = default;
};
Sales_data:Sales_data() = default;
````
这种形式的默认构造函数执行与编译器合成的默认构造函数一样的功能。通过在参数列表后加上 `= default` 将要求编译器为我们生成默认构造函数。`=default` 可以出现在类内的声明处，或者出现在函数定义处。定义在类内则合成的默认构造函数自动称为内联的，定义在类外则是非内联的。这两种形式的差异还在于定义在类外的函数是用户提供（user-provided）的构造函数。用户提供的构造函数在对象是值初始化时，将执行默认初始化。而编译器生成的默认构造函数，在值初始化时，将先执行零初始化再执行默认初始化。

在 C++11 之后才提供类内初始化，在之前的 C++ 版本是不提供的，此时必须使用构造初始值列表（constructor initializer list）来初始化所有成员。

**构造初始值列表**
````cpp
Sales_data(const string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
````
在参数列表后的冒号直到函数体的括弧之间的代码称为构造初始值列表（constructor initializer list），它的作用是给对象的成员提供初始值，它是一系列的成员名，在每个成员名后跟随括号或括弧中的初始值，多个成员初始值之间用逗号分隔。

当一个成员从构造初始值列表中省去时，它是默认初始化的，使用合成构造函数的初始化规则。

使用类内初始值的好处在于不必每次都在构造初始值列表中提供值。如果语言版本不支持的话，则需要在每个构造函数中初始化每一个内置类型的成员。

以上构造函数的函数体是空的，这在 C++ 中是很常见的，这个构造函数所做的工作就是给数据成员提供值。

**在类外定义构造函数**
````cpp
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this);
}
````
定义在类外的构造函数没有返回类型，直接从名字开始，亦无返回语句。与其它成员函数一样，函数名字需要用类名进行限定。尽管此处构造初始值列表是空的，类成员依然在构造函数体执行之前先初始化，此时这些没有出现在构造初始值列表中的成员将被默认初始化或被类内初始值进行初始化。

### 7.1.5 拷贝、赋值和析构

除了定义类对象如何初始化，类还可以控制对象赋值（copy）、赋值（assign）和销毁（destroy）时的操作。当初始化变量或者传递参数、返回值时将发生对象复制。当使用赋值操作符时发生赋值操作。当离开定义对象所在的块时将销毁对象，当 vector 或数组被销毁时，其中元素亦被销毁。

如果程序员不定义这些操作的函数，编译器将合成这些函数。通常，编译器生成的版本就是将对象的每个成员分别进行拷贝、赋值和销毁。如编译器生成的 Sales_data 的赋值函数如：
````cpp
total = trans;
//////////////////
total.bookNo = trans.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;
````

**有些类不能依赖于合成版本**

尽管编译器可以合成拷贝、赋值和析构函数，但需要记住的是默认版本的行为不一定是符合要求的。特别是当类在类对象本身外部分配了资源时（动态内存、数据库连接、TCP 连接），合成版本通常无法正确工作。通常如果类有分配动态内存，是不能依赖合成的版本。

值得提醒的时，很多需要动态内存管理的类可以使用 string 或 vector 来管理需要内存。使用这些组件的类避免了分配和回收内存的复杂度，而且合成的函数可以在此之上正确工作。当拷贝带有 vector 成员的对象时，vector 类会正确处理其中元素的拷贝和赋值。当销毁时，vector 将被销毁，其中的元素亦被销毁。

直到你知道如何正确定义以上三种函数时，尽量不要在类所占据内存外分配资源。

## 7.2 访问控制和封装

在 C++ 中使用访问说明符（access specifiers）来强制封装，即信息隐藏：

- 定义在 public 说明符后的成员程序的所有部分都可以访问的，public 成员是类的接口（interface）；
- 定义在 private 说明符后的成员只能由本类中其它部分访问，不能被使用类的代码使用，private 成员封装了类的实现；

一个类可以有零个或多个访问说明符，对于一个访问说明符出现的频率并没有限制。每个访问说明符说明接下来的成员访问级别，这些访问级别持续到下一个访问说明符的出现或者类的结尾。

**使用 class 或 struct 关键字**

使用 class 关键字或者 struct 关键字唯一的区别在于默认的访问级别。对于 struct 关键字而言，定义在第一个访问说明符前的成员是共有的，对于 class 而言则是私有的。即 class 的默认访问说明符是 private，而 struct 的默认访问说明符是 public 。

### 7.2.1 友元

尽管类相关的非类成员函数在概念上是类的一部分，但是依然需要遵循常规函数的规则，即不能访问类的私有成员。一个类可以通过将另一个类或函数定义为 friend 来使得其可以访问此类的非 public 成员。这样做只需要简单地将类或函数声明放在类内，并在之前加上 friend 关键字即可。如：
````cpp
class Sales_data {
    friend Sales_data add(const Sales_data&, const Sales_data&);
    friend istream &read(istream&, Sales_data&);
};
Sales_data add(const Sales_data&, const Sales_data&);
istream &read(istream&, Sales_data&);
````
友元声明需要放在类定义内，它们可以出现在类的任何地方。友元不是类的成员，因而，不受访问控制的影响。将所有的友元声明集中放在一起，或置于类定义头部或尾部，是一个好的处理方式。

**封装的益处**

使用封装可以防止被封装的对象状态被破坏；被封装的类的实现可以随着时间的推移进行修改而不需要涉及到用户代码的修改，api 的改变往往会导致用户的怨声载道。将数据定义为 private 的，类的作者可以按照自己的意愿改变其中数据。实现的概念只会影响到类中使用到此部分代码的行为，测试仅限于这些部分。而改变接口往往会涉及到用户代码的改变，所有依赖于旧接口的代码都会被打破，导致要重写所有这些使用旧接口的代码。

将数据设置为 private 的另一个好处是数据不会被用户无意中改变。如果有一个 bug 破坏了对象的状态，查找 bug 的地方将仅限于实现代码，从而极大简化了维护成本。

尽管封装避免了用户代码的改变，但改变类实现代码依然需要编译所有用到此类的源文件必须重新编译。

**声明友元**

友元声明只说明了访问权限，它并不是一个通用的函数声明。为了调用此友元函数，依然需要在类外部声明函数本身，如上面所做的那样。为了使友元函数为用户所见，通常在同一个头文件中再次声明这些函数。

需要编译器并不强制要求友元函数必须在类外再次声明，但并不是所有编译器都支持。为了最大的兼容性，最好在类外部再次声明函数。

## 7.3 其它类特性
### 7.3.1 类成员
### 7.3.2 返回 `*this` 的函数
### 7.3.3 类类型
### 7.3.4 友元再探
## 7.4 类作用域
### 7.4.1 名称查找和类作用域
## 7.5 构造函数再探
### 7.5.1 构造函数初始值列表
### 7.5.2 代理构造函数
### 7.5.3 默认构造函数的角色
### 7.5.4 隐式类类型转换
### 7.5.5 聚合类
### 7.5.6 字面类
## 7.6 static 成员
## 关键概念
