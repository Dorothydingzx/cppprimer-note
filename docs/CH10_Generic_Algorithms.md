标准库容器定义了相当少的操作，与其添加无数的功能到每一个容器中，标准库提供了一系列算法，其中大部分独立于任何特定的容器类型。这些算法是通用的（generic）：它们在不同类型的容器和元素上进行操作。

本章的内容主要包括通用算法（generci algorithms）和更加详细的介绍迭代器。

顺序容器定义了简约的操作：其中大部分用于添加移除元素，访问首尾元素，判断容器是否为空，以及获取首元素和尾后元素的迭代器。

我们可以想象还需要其它有用的操作：查找特定的元素，替换或移除特定值，重排序容器中的元素。

与其将这些操作定义为每个容器类型的成员，标准库定义了一系列通用算法：“算法”意思是它们实现了常见的经典算法如排序和搜索，“通用”是由于它们操作与不同类型的元素以及跨越多种容器类型——不仅仅是标准库中的类型如 vector 和 list，还包括内置数组类型以及其它自定义的序列（sequences）类型。

## 10.1 概述

绝大部分算法定义在 algorithm 头文件中。标准库还在 numeric 头文件中定义了一小撮通用数字算法（generic numeric algorithms）。

通常来说，算法并不直接在容器上进行工作，而是通过遍历由两个迭代器组成的元素范围进行操作。当算法遍历整个范围时，它会对每个元素做一些事情。如要查找容器中的特定元素值最简单的方式是调用 find 算法：
````cpp
int val = 42;
auto result = find(vec.cbegin(), vec.cend(), val);
````
find 的前两个参数是两个迭代器，它们组成了一个左包含的元素范围，第三个参数是一个值。find 将给定范围中的每个元素与待查找的值进行比较。它返回第一个等于这个值的第一个元素的迭代器。如果没有找到，find 将返回其第二个参数来表示失败。因而，我们可以通过比较返回值是否与第二个迭代器参数相等来判断是否找到。

由于 find 仅对迭代器操作，可以将 find 用于任何的容器类型。如将 find 用于 `list<string>`：
````cpp
string val = "a value";
auto result = find(lst.cbegin(), lst.cend(), val);
````
由于内置数组中的指针与迭代器的行为非常类似，可以将 find 用于数组：
````cpp
int ia[] = {27,210,12,47,109,83};
int val = 83;
int* result = find(begin(ia), end(ia), val);
````
此处值得注意的是调用了库函数 begin 和 end 来获取 ia 的首元素指针和尾后元素指针。

通过传递子范围的首元素和尾后元素的迭代器（或指针）从而仅对容器的子范围进行查找。如：
````cpp
// 搜索元素从 a[1] 开始直到但不包括 ia[4]
auto result = find(ia+1, ia+4, val);
````

**算法如何工作**

通过考察 find 算法来了解算法是如何运用于不同的容器类型的。find 可以在未排序的一系列元素中查找特定的元素。以下是它采取的步骤：

1. 访问序列的首元素；
2. 将其与给定值进行比较；
3. 如果这个元素匹配给定的值，find 将返回迭代器或者指针来标识这个元素；
4. 否则 find 继续查找下一个元素，重复步骤 2 和 3；
5. find 必须在到达序列的末尾时结束；
6. 如果 find 到了序列的末尾，需要返回一个值来表示元素没有找到。返回的值需要与第 3 步中的类型相兼容；

以上所有操作都没有依赖于容器的类型，只要能够使用迭代器来访问元素，find 根本不需要依赖于容器的类型。

**迭代器使得算法与容器互相独立**

除了第二步之外的所有步骤都可以通过迭代器进行操作：迭代器解引用可以访问元素；如果找到了匹配的元素，find 将返回那个元素的迭代器；迭代器的自增操作将移动到下一个元素；“尾后”迭代器表示 find 已经到达了给定序列的尾部；find 返回尾后迭代器用于表示没有找到指定的值；

**但是算法依赖于元素类型的操作**

尽管迭代器使得算法和容器类型相互独立，大部分的算法使用一个或多个元素类型的操作。如：第 2 步用元素类型的 `==` 操作符比较每个元素和给定值。

其它的算法需要元素类型由 `<` 操作符。然而，绝大部分的算法还提供了一种方式允许我们提供自己的操作用于替换默认的行为。

**关键概念：算法永不执行容器的操作**

通用算法自己不会执行容器的操作。它们只会操作迭代器。算法不直接调用容器的成员函数有一个重要的隐喻：算法永远不会改变底层容器的长度。算法可能会改变元素的值，可能会在容器中移动元素，但是它们不会直接添加或移除元素。

我们将在后面看到，有一种特殊类别的迭代器——插入器（inserter），除了遍历序列之外。当我们给这个迭代器赋值时，它将在底层容器中执行插入操作。当算法操作在这种迭代器上时，迭代器具有加元素到容器中的效果。但是算法本身不会插入元素，甚至它都不知道插入元素这回事。

## 10.2 算法入门

标准库提供了超过 100 个算法。幸运的是算法有固定的结构。理解结构使得学习和使用算法比记住 100 个以上的算法要容易。在本章，我们将描述如何使用算法，并且讲解它们的组织原则。附录 A 中按照算法的操作进行分类列举。

除了一些小的例外，算法操作于一组元素。我们称这个范围为“输入范围”（input range）。带输入范围的算法总是用其前两个参数来表示范围。这两个参数分别表示要处理的首元素和尾后元素。

尽管绝大部分算法都处理一组输入范围，它们操作元素的方式不一样。理解算法的最基本的方法是直到它们是读元素、写元素还是对元素进行重排序。

### 10.2.1 只读算法

有很多算法对输入范围只读不写。find 和 count 算法就是一个例子。另外一个只读算法是 accumulate，它定义在 numeric 头文件中。accumulate 函数有三个参数，前两个指定输入范围，第三个参数是综合的初始值。假设 vec 是一个整数序列，那么：
````cpp
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
````
第三个参数的类型决定了使用哪个加操作，并且是 accumulate 的返回值类型。

**算法和元素类型**

accumulate 使用其第三个参数作为求和的起点有一个重要的隐喻：元素类型必须与总和的类型可以相加。也就是说元素的类型必须与第三个参数的类型相匹配或者可以相互转换。在这个例子中 vec 中的元素类型可以是 int，double，long long 或者其它可以与 int 相加的类型。

另外一个例子是 string 有加操作符，可以通过调用 accumulate 将 vector 中的元素拼接起来：
````cpp
string sum = accumulate(v.cbegin(), v.cend(), string(""));
````
这个调用 v 中的每个元素拼接到一个 string 上，这个 string 最开始是空字符串，请注意这里需要显示创建 string 作为第三个参数，如果传递的是空字符串字面量将会是编译时错误：
````cpp
// error: const char* 上没有加操作符
string sum = accumulate(v.cbegin(), v.cend(), "");
````
如果传递 string 字面量，存储 sum 的对象类型将是  `const char*`，这个类型决定了使用哪个加号操作符。由于 `const char*` 上没有加操作符，这个调用将无法通过编译。

通常在只读算法上最好使用 cbegin() 和 cend()，如果打算使用返回的迭代器来改变元素的值就要传递 begin() 和 end() 。

**在两个序列上进行操作的算法**

另外一个只读算法是 equal，用于判断是否两个序列中的值完全一样。它将第一个序列中的每个元素与第二个序列中对应位置的元素进行比较，如果所有的对应位置的元素都相等，返回 true，否则返回 false。这个算法有三个迭代器：前两个表示第一个序列的范围，首元素和尾后迭代器；第三个是第二个序列的首元素：
````cpp
// roster2 至少要有与 roster1 一样多的元素
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
````
由于 equal 在是迭代器上定义的，可以将 equal 用于比较不同类型的容器中的元素。甚至，元素类型也不需要完全一致，只要可以使用 `==` 进行元素值比较就行。如，roster1 可以是 `vector<string>` ，roster2 可以是 `list<const char*>` 。

然而，equal 做出了一个严格的假设：它假设第二个序列至少跟第一个序列一样长。这个算法潜在地会遍历第一个序列中的所有元素。它假设第二个序列中一定会有对应的元素。

**警告：**以单个迭代器表示第二个序列的算法会*假设*第二个序列至少跟第一个序列一样长。

### 10.2.2 写容器元素的算法

一些算法会给序列中的元素赋予新值。当使用会对元素赋值的算法时需要注意，必须保证算法写入的序列其大小大于等于需要写入的数目。记住，算法不会直接调用任何容器的操作，所以它们本身没有任何办法改变容器的大小。

其中一部分算法只会对输入范围内的元素进行写入，它们没有上面谈到的危险，原因是它们只会对输入范围内的元素进行写入。

比如，fill 以一对迭代器表示范围，以及第三个参数表示要写入的值。fill 将给定值赋值给范围内的所有元素。如：
````cpp
fill(vec.begin(), vec.end(), 0);
fill(vec.begin(), vec.begin() + vec.size()/2, 10);
````
由于 fill 只会往给定的输入序列中写入值，只要传入的是合法的输入序列，那么写入将是安全的。

**关键概念：迭代器参数**

有些算法同时从两个序列中读取元素，构成这些序列的的元素可以被存储在不同类型的容器中。如第一个序列可能被存储在 vector 中，第二个序列则存储在 list 或者 deque ，内置数组或者别的类型中。甚至，两个列中的元素类型都不需要完全匹配。只要能够比较两个序列中的元素。比如，在 equal 算法中，元素类型不需要完全一致，但是需要可以使用 `==` 来比较两个序列中的元素。

操作两个序列的算法的不同之处在于如何传递第二个序列。有一些算法比如 equal，有三个迭代器：前两个表示第一个序列的范围，第三个迭代器表示第二序列的首元素。其它的算法以四个迭代器为参数：分别表示两个序列的范围。

使用一个迭代器表示第二个序列的算法假设第二个序列至少有第一个序列那么长。由程序员保证算法不会访问第二个序列中不存在的元素。比如 equal 有可能会将第一个序列中的每个元素与第二序列中的对应位置的元素进行比较。如果第二个序列是第一个序列的子序列，那么将会产生很严重的错误 —— equal 将会访问超出第二个序列尾部的元素。

**算法不会检查输出操作**

有些算法只有一个单独的迭代器表示写入目标。这些算法将新值赋值到以目标迭代器（destination iterator）表示的元素开始的序列的元素中。 `fill_n` 以一个迭代器，计数器和值作为参数。它将这个给定值赋值到从迭代器所表示的元素开始的指定数目的元素中去。如：
````cpp
vecotr<int> vec;
fill_n(vec.begin(), vec.size(), 0);
````
`fill_n` 假设写入指定数目的元素是安全的。这是因为在调用 `fill_n(dest, n, val)` 中，`fill_n` 假设 dest 表示一个元素，并且从 dest 开始至少有 n 个元素。

对于初学者来说，在空容器上调用 `fill_n` （以及其它写入的算法）是一个常见的错误：
````cpp
vector<int> vec;
// 试图写入 10 个不存在的元素是严重的错误
fill_n(vec.begin(), 10, 0);
````
这个调用想要写入 10 个元素，但是容器中根本没有元素。结果是未定义的。

**警告：** 写入到目标迭代器的算法假设目标序列足以容纳将要写入的元素。

**介绍 `back_inserter`**

有一种保证算法有足够的元素用以写入，那就是使用插入迭代器（insert iterator）。插入迭代器是往容器中添加元素的迭代器。平常，当我们给迭代器赋值时，我们是给迭代器所表示的元素赋值。当我们给插入迭代器赋值时，一个等于右边值的新元素被添加到容器中。

插入迭代器将在后面更为详细的介绍，现在我们先使用 `back_inserter` 来举几个例子，`back_inserter` 是定义在 iterator 头文件中的函数。

`back_inserter` 以容器引用为参数，返回一个绑定到容器上的插入迭代器。当通过这个迭代器给元素赋值时，将调用容器的 `push_back` 函数给容器添加元素。如：
````cpp
vector<int> vec;
auto it = back_inserter(vec);
*it = 42;
````
我们经常用 `back_inserter` 创建的迭代器用作算法的目的迭代器。如：
````cpp
vector<int> vec;
fill_n(back_inserter(vec), 10, 0);
````
在每次迭代时，`fill_n` 给序列中的元素赋值，由于我们传入的是 `back_inserter` 的返回值，每次赋值都将调用 vec 的 `push_back` ，因而每次赋值 `fill_n` 都会添加一个元素到容器的尾部。

**拷贝算法**

copy 算法是另一个将值写入到由目的迭代器表示的输出序列中的例子。这个算法只有三个参数。前两个表示输入序列；第三个表示输出序列的首元素。这个算法将输入范围内的元素拷贝输出序列中。有一点很重要的是传递给 copy 的输出序列至少要和输入序列一样长。如将值拷贝内置数组中去：
````cpp
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];
auto ret = copy(begin(a1), end(a1), a2);
````
copy 的返回值是自增后的目的迭代器。意味着 ret 将指向 a2 的尾后位置。

有多个算法提供了“拷贝”版本，相比于将计算后的值重新存入输入序列中，这个算法创建一个新的序列以容纳结果。比如 replace 算法接收四个参数：两个迭代器表示输入序列，以及两个值。它将序列中的每个等于第一个值的元素替换为第二个值。如：
````cpp
replace(ilist.begin(), ilist.end(), 0, 42);
````
上面的调用将所有的 0 替换为 42。如果想要保持原始的容器不变的话，需要调用 `replace_copy` ，这个算法有第三个迭代器参数表示输出目的地。如：
````cpp
replace_copy(ilist.cbegin(), ilist.cend(), back_inserter(ivec), 0, 42);
````
在此调用之后 ilist 将保持不变，而 ivec 的元素将是 ilist 拷贝，并将其中所有的 0 替换为 42。

### 10.2.3 对容器元素进行重排序的算法

有些算法对容器中的元素进行重排序，一个显著的例子就是 sort 算法。调用 sort 将使用元素的 `<` 操作符将输入范围内的元素排序。

**消除元素**

一个例子是消除容器中的相同的字符串。首先对这些字符串进行排序，然后调用 unique 将所有唯一的字符串放到容器的首部，并返回最后一个唯一字符串的下一个位置的迭代器。unique 本身是不改变容器的大小的，所以需要用容器的 erase 成员移除元素：
````cpp
void elimDups(vector<string> &words)
{
    sort(words.begin(), words.end());
    auto end_unique = unique(words.begin(), words.end());
    words.erase(end_unique, words.end());
}
````
调用完 unique 之后，返回值迭代器后面的值到底是什么我们无法知道，它可能已经被算法给改写了。

由于标准库算法是在迭代器而不是容器上进行操作，算法不能直接添加或移除元素。

**使用容器操作来移除元素**

为了移除无用的元素，必须使用容器的操作。

## 10.3 定制操作

大多数算法会比较容器中的元素。默认情况下算法使用的是 `<` 或 `==` 操作符。算法还定义了允许我们提供自己的操作来替换默认操作符的版本。

比如对于 sort 算法使用的是 `<` 操作符。可能我们的序列并不是按照 `<` 进行排序的，或者有些类型根本就没有 `<` 操作符，在这两种情况下都需要重载默认的 sort 行为。

### 10.3.1 传递函数给算法

对于字符串序列进行排序可以是先按照长度进行排序，对于长度一样的再按照字典顺序进行排序。为了这样做需要使用第二个版本的 sort，这个版本的 sort 有第三个参数称之为谓词（predicate）。

**谓词**

谓词是一个可以被调用然后返回一个值的表达式，返回值可以作为条件使用。标准库使用的谓词可以是一元谓词（unary predicate）（意思是只有一个参数）也可以是二元谓词（binary predicate）（意思是有两个参数）。带有谓词的算法在输入范围内的元素上调用这个谓词。因而，必须要可以将元素类型转为谓词的参数类型。

使用二元谓词的 sort 版本将给定谓词替换 `<` 操作用于比较元素。提供给 sort 算法的谓词必须满足 §11.2.2 中描述的限制，现在我们只需要知道这个操作必须在每一个元素之间提供稳定的顺序。单纯比较字符串的长度就是其中一个例子。如：
````cpp
bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
}
sort(words.begin(), words.end(), isShorter);
````
这样所有的字符串就是按照长度进行排序的了。

### 10.3.2 lambda 表达式
### 10.3.3 lambda 捕获和返回
### 10.3.4 绑定实参
## 10.4 再谈迭代器
### 10.4.1 插入迭代器
### 10.4.2 iostream 迭代器
### 10.4.3 反转迭代器
## 10.5 通用算法的分类
### 10.5.1 按照5种迭代器分类
### 10.5.2 按照算法的参数模式分配
### 10.5.3 算法名字的约定
## 10.6 特定于容器的算法
## 关键术语
