标准库容器定义了相当少的操作，与其添加无数的功能到每一个容器中，标准库提供了一系列算法，其中大部分独立于任何特定的容器类型。这些算法是通用的（generic）：它们在不同类型的容器和元素上进行操作。

本章的内容主要包括通用算法（generci algorithms）和更加详细的介绍迭代器。

顺序容器定义了简约的操作：其中大部分用于添加移除元素，访问首尾元素，判断容器是否为空，以及获取首元素和尾后元素的迭代器。

我们可以想象还需要其它有用的操作：查找特定的元素，替换或移除特定值，重排序容器中的元素。

与其将这些操作定义为每个容器类型的成员，标准库定义了一系列通用算法：“算法”意思是它们实现了常见的经典算法如排序和搜索，“通用”是由于它们操作与不同类型的元素以及跨越多种容器类型——不仅仅是标准库中的类型如 vector 和 list，还包括内置数组类型以及其它自定义的序列（sequences）类型。

## 10.1 概述

绝大部分算法定义在 algorithm 头文件中。标准库还在 numeric 头文件中定义了一小撮通用数字算法（generic numeric algorithms）。

通常来说，算法并不直接在容器上进行工作，而是通过遍历由两个迭代器组成的元素范围进行操作。当算法遍历整个范围时，它会对每个元素做一些事情。如要查找容器中的特定元素值最简单的方式是调用 find 算法：
````cpp
int val = 42;
auto result = find(vec.cbegin(), vec.cend(), val);
````
find 的前两个参数是两个迭代器，它们组成了一个左包含的元素范围，第三个参数是一个值。find 将给定范围中的每个元素与待查找的值进行比较。它返回第一个等于这个值的第一个元素的迭代器。如果没有找到，find 将返回其第二个参数来表示失败。因而，我们可以通过比较返回值是否与第二个迭代器参数相等来判断是否找到。

由于 find 仅对迭代器操作，可以将 find 用于任何的容器类型。如将 find 用于 `list<string>`：
````cpp
string val = "a value";
auto result = find(lst.cbegin(), lst.cend(), val);
````
由于内置数组中的指针与迭代器的行为非常类似，可以将 find 用于数组：
````cpp
int ia[] = {27,210,12,47,109,83};
int val = 83;
int* result = find(begin(ia), end(ia), val);
````
此处值得注意的是调用了库函数 begin 和 end 来获取 ia 的首元素指针和尾后元素指针。

通过传递子范围的首元素和尾后元素的迭代器（或指针）从而仅对容器的子范围进行查找。如：
````cpp
// 搜索元素从 a[1] 开始直到但不包括 ia[4]
auto result = find(ia+1, ia+4, val);
````

**算法如何工作**

通过考察 find 算法来了解算法是如何运用于不同的容器类型的。find 可以在未排序的一系列元素中查找特定的元素。以下是它采取的步骤：

1. 访问序列的首元素；
2. 将其与给定值进行比较；
3. 如果这个元素匹配给定的值，find 将返回迭代器或者指针来标识这个元素；
4. 否则 find 继续查找下一个元素，重复步骤 2 和 3；
5. find 必须在到达序列的末尾时结束；
6. 如果 find 到了序列的末尾，需要返回一个值来表示元素没有找到。返回的值需要与第 3 步中的类型相兼容；

以上所有操作都没有依赖于容器的类型，只要能够使用迭代器来访问元素，find 根本不需要依赖于容器的类型。

**迭代器使得算法与容器互相独立**

除了第二步之外的所有步骤都可以通过迭代器进行操作：迭代器解引用可以访问元素；如果找到了匹配的元素，find 将返回那个元素的迭代器；迭代器的自增操作将移动到下一个元素；“尾后”迭代器表示 find 已经到达了给定序列的尾部；find 返回尾后迭代器用于表示没有找到指定的值；

**但是算法依赖于元素类型的操作**

尽管迭代器使得算法和容器类型相互独立，大部分的算法使用一个或多个元素类型的操作。如：第 2 步用元素类型的 `==` 操作符比较每个元素和给定值。

其它的算法需要元素类型由 `<` 操作符。然而，绝大部分的算法还提供了一种方式允许我们提供自己的操作用于替换默认的行为。

**关键概念：算法永不执行容器的操作**

通用算法自己不会执行容器的操作。它们只会操作迭代器。算法不直接调用容器的成员函数有一个重要的隐喻：算法永远不会改变底层容器的长度。算法可能会改变元素的值，可能会在容器中移动元素，但是它们不会直接添加或移除元素。

我们将在后面看到，有一种特殊类别的迭代器——插入器（inserter），除了遍历序列之外。当我们给这个迭代器赋值时，它将在底层容器中执行插入操作。当算法操作在这种迭代器上时，迭代器具有加元素到容器中的效果。但是算法本身不会插入元素，甚至它都不知道插入元素这回事。

## 10.2 算法入门

标准库提供了超过 100 个算法。幸运的是算法有固定的结构。理解结构使得学习和使用算法比记住 100 个以上的算法要容易。在本章，我们将描述如何使用算法，并且讲解它们的组织原则。附录 A 中按照算法的操作进行分类列举。

除了一些小的例外，算法操作于一组元素。我们称这个范围为“输入范围”（input range）。带输入范围的算法总是用其前两个参数来表示范围。这两个参数分别表示要处理的首元素和尾后元素。

尽管绝大部分算法都处理一组输入范围，它们操作元素的方式不一样。理解算法的最基本的方法是直到它们是读元素、写元素还是对元素进行重排序。

### 10.2.1 只读算法

有很多算法对输入范围只读不写。find 和 count 算法就是一个例子。另外一个只读算法是 accumulate，它定义在 numeric 头文件中。accumulate 函数有三个参数，前两个指定输入范围，第三个参数是综合的初始值。假设 vec 是一个整数序列，那么：
````cpp
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
````
第三个参数的类型决定了使用哪个加操作，并且是 accumulate 的返回值类型。

**算法和元素类型**

accumulate 使用其第三个参数作为求和的起点有一个重要的隐喻：元素类型必须与总和的类型可以相加。也就是说元素的类型必须与第三个参数的类型相匹配或者可以相互转换。在这个例子中 vec 中的元素类型可以是 int，double，long long 或者其它可以与 int 相加的类型。

另外一个例子是 string 有加操作符，可以通过调用 accumulate 将 vector 中的元素拼接起来：
````cpp
string sum = accumulate(v.cbegin(), v.cend(), string(""));
````
这个调用 v 中的每个元素拼接到一个 string 上，这个 string 最开始是空字符串，请注意这里需要显示创建 string 作为第三个参数，如果传递的是空字符串字面量将会是编译时错误：
````cpp
// error: const char* 上没有加操作符
string sum = accumulate(v.cbegin(), v.cend(), "");
````
如果传递 string 字面量，存储 sum 的对象类型将是  `const char*`，这个类型决定了使用哪个加号操作符。由于 `const char*` 上没有加操作符，这个调用将无法通过编译。

通常在只读算法上最好使用 cbegin() 和 cend()，如果打算使用返回的迭代器来改变元素的值就要传递 begin() 和 end() 。

**在两个序列上进行操作的算法**

另外一个只读算法是 equal，用于判断是否两个序列中的值完全一样。它将第一个序列中的每个元素与第二个序列中对应位置的元素进行比较，如果所有的对应位置的元素都相等，返回 true，否则返回 false。这个算法有三个迭代器：前两个表示第一个序列的范围，首元素和尾后迭代器；第三个是第二个序列的首元素：
````cpp
// roster2 至少要有与 roster1 一样多的元素
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
````
由于 equal 在是迭代器上定义的，可以将 equal 用于比较不同类型的容器中的元素。甚至，元素类型也不需要完全一致，只要可以使用 `==` 进行元素值比较就行。如，roster1 可以是 `vector<string>` ，roster2 可以是 `list<const char*>` 。

然而，equal 做出了一个严格的假设：它假设第二个序列至少跟第一个序列一样长。这个算法潜在地会遍历第一个序列中的所有元素。它假设第二个序列中一定会有对应的元素。

**警告：**以单个迭代器表示第二个序列的算法会*假设*第二个序列至少跟第一个序列一样长。

### 10.2.2 写容器元素的算法

一些算法会给序列中的元素赋予新值。当使用会对元素赋值的算法时需要注意，必须保证算法写入的序列其大小大于等于需要写入的数目。记住，算法不会直接调用任何容器的操作，所以它们本身没有任何办法改变容器的大小。

其中一部分算法只会对输入范围内的元素进行写入，它们没有上面谈到的危险，原因是它们只会对输入范围内的元素进行写入。

比如，fill 以一对迭代器表示范围，以及第三个参数表示要写入的值。fill 将给定值赋值给范围内的所有元素。如：
````cpp
fill(vec.begin(), vec.end(), 0);
fill(vec.begin(), vec.begin() + vec.size()/2, 10);
````
由于 fill 只会往给定的输入序列中写入值，只要传入的是合法的输入序列，那么写入将是安全的。

**关键概念：迭代器参数**

有些算法同时从两个序列中读取元素，构成这些序列的的元素可以被存储在不同类型的容器中。如第一个序列可能被存储在 vector 中，第二个序列则存储在 list 或者 deque ，内置数组或者别的类型中。甚至，两个列中的元素类型都不需要完全匹配。只要能够比较两个序列中的元素。比如，在 equal 算法中，元素类型不需要完全一致，但是需要可以使用 `==` 来比较两个序列中的元素。

操作两个序列的算法的不同之处在于如何传递第二个序列。有一些算法比如 equal，有三个迭代器：前两个表示第一个序列的范围，第三个迭代器表示第二序列的首元素。其它的算法以四个迭代器为参数：分别表示两个序列的范围。

使用一个迭代器表示第二个序列的算法假设第二个序列至少有第一个序列那么长。由程序员保证算法不会访问第二个序列中不存在的元素。比如 equal 有可能会将第一个序列中的每个元素与第二序列中的对应位置的元素进行比较。如果第二个序列是第一个序列的子序列，那么将会产生很严重的错误 —— equal 将会访问超出第二个序列尾部的元素。

**算法不会检查输出操作**

有些算法只有一个单独的迭代器表示写入目标。这些算法将新值赋值到以目标迭代器（destination iterator）表示的元素开始的序列的元素中。 `fill_n` 以一个迭代器，计数器和值作为参数。它将这个给定值赋值到从迭代器所表示的元素开始的指定数目的元素中去。如：
````cpp
vecotr<int> vec;
fill_n(vec.begin(), vec.size(), 0);
````
`fill_n` 假设写入指定数目的元素是安全的。这是因为在调用 `fill_n(dest, n, val)` 中，`fill_n` 假设 dest 表示一个元素，并且从 dest 开始至少有 n 个元素。

对于初学者来说，在空容器上调用 `fill_n` （以及其它写入的算法）是一个常见的错误：
````cpp
vector<int> vec;
// 试图写入 10 个不存在的元素是严重的错误
fill_n(vec.begin(), 10, 0);
````
这个调用想要写入 10 个元素，但是容器中根本没有元素。结果是未定义的。

**警告：** 写入到目标迭代器的算法假设目标序列足以容纳将要写入的元素。

**介绍 `back_inserter`**

有一种保证算法有足够的元素用以写入，那就是使用插入迭代器（insert iterator）。插入迭代器是往容器中添加元素的迭代器。平常，当我们给迭代器赋值时，我们是给迭代器所表示的元素赋值。当我们给插入迭代器赋值时，一个等于右边值的新元素被添加到容器中。

插入迭代器将在后面更为详细的介绍，现在我们先使用 `back_inserter` 来举几个例子，`back_inserter` 是定义在 iterator 头文件中的函数。

`back_inserter` 以容器引用为参数，返回一个绑定到容器上的插入迭代器。当通过这个迭代器给元素赋值时，将调用容器的 `push_back` 函数给容器添加元素。如：
````cpp
vector<int> vec;
auto it = back_inserter(vec);
*it = 42;
````
我们经常用 `back_inserter` 创建的迭代器用作算法的目的迭代器。如：
````cpp
vector<int> vec;
fill_n(back_inserter(vec), 10, 0);
````
在每次迭代时，`fill_n` 给序列中的元素赋值，由于我们传入的是 `back_inserter` 的返回值，每次赋值都将调用 vec 的 `push_back` ，因而每次赋值 `fill_n` 都会添加一个元素到容器的尾部。

**拷贝算法**

copy 算法是另一个将值写入到由目的迭代器表示的输出序列中的例子。这个算法只有三个参数。前两个表示输入序列；第三个表示输出序列的首元素。这个算法将输入范围内的元素拷贝输出序列中。有一点很重要的是传递给 copy 的输出序列至少要和输入序列一样长。如将值拷贝内置数组中去：
````cpp
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];
auto ret = copy(begin(a1), end(a1), a2);
````
copy 的返回值是自增后的目的迭代器。意味着 ret 将指向 a2 的尾后位置。

有多个算法提供了“拷贝”版本，相比于将计算后的值重新存入输入序列中，这个算法创建一个新的序列以容纳结果。比如 replace 算法接收四个参数：两个迭代器表示输入序列，以及两个值。它将序列中的每个等于第一个值的元素替换为第二个值。如：
````cpp
replace(ilist.begin(), ilist.end(), 0, 42);
````
上面的调用将所有的 0 替换为 42。如果想要保持原始的容器不变的话，需要调用 `replace_copy` ，这个算法有第三个迭代器参数表示输出目的地。如：
````cpp
replace_copy(ilist.cbegin(), ilist.cend(), back_inserter(ivec), 0, 42);
````
在此调用之后 ilist 将保持不变，而 ivec 的元素将是 ilist 拷贝，并将其中所有的 0 替换为 42。

### 10.2.3 对容器元素进行重排序的算法

有些算法对容器中的元素进行重排序，一个显著的例子就是 sort 算法。调用 sort 将使用元素的 `<` 操作符将输入范围内的元素排序。

**消除元素**

一个例子是消除容器中的相同的字符串。首先对这些字符串进行排序，然后调用 unique 将所有唯一的字符串放到容器的首部，并返回最后一个唯一字符串的下一个位置的迭代器。unique 本身是不改变容器的大小的，所以需要用容器的 erase 成员移除元素：
````cpp
void elimDups(vector<string> &words)
{
    sort(words.begin(), words.end());
    auto end_unique = unique(words.begin(), words.end());
    words.erase(end_unique, words.end());
}
````
调用完 unique 之后，返回值迭代器后面的值到底是什么我们无法知道，它可能已经被算法给改写了。

由于标准库算法是在迭代器而不是容器上进行操作，算法不能直接添加或移除元素。

**使用容器操作来移除元素**

为了移除无用的元素，必须使用容器的操作。

## 10.3 定制操作

大多数算法会比较容器中的元素。默认情况下算法使用的是 `<` 或 `==` 操作符。算法还定义了允许我们提供自己的操作来替换默认操作符的版本。

比如对于 sort 算法使用的是 `<` 操作符。可能我们的序列并不是按照 `<` 进行排序的，或者有些类型根本就没有 `<` 操作符，在这两种情况下都需要重载默认的 sort 行为。

### 10.3.1 传递函数给算法

对于字符串序列进行排序可以是先按照长度进行排序，对于长度一样的再按照字典顺序进行排序。为了这样做需要使用第二个版本的 sort，这个版本的 sort 有第三个参数称之为谓词（predicate）。

**谓词**

谓词是一个可以被调用然后返回一个值的表达式，返回值可以作为条件使用。标准库使用的谓词可以是一元谓词（unary predicate）（意思是只有一个参数）也可以是二元谓词（binary predicate）（意思是有两个参数）。带有谓词的算法在输入范围内的元素上调用这个谓词。因而，必须要可以将元素类型转为谓词的参数类型。

使用二元谓词的 sort 版本将给定谓词替换 `<` 操作用于比较元素。提供给 sort 算法的谓词必须满足 §11.2.2 中描述的限制，现在我们只需要知道这个操作必须在每一个元素之间提供稳定的顺序。单纯比较字符串的长度就是其中一个例子。如：
````cpp
bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
}
sort(words.begin(), words.end(), isShorter);
````
这样所有的字符串就是按照长度进行排序的了。

**排序算法**

当使用长度进行排序时，我们依然希望保持相同长度的元素之间的字典排序。为了达到这样的效果，我们将使用 `stable_sort` 算法。稳定排序（stable sort）将保持原来相等的元素之间的顺序。

通常，我们并不关心相等元素之间的相对顺序，毕竟它们都是相等的。然而，现在的情况是我们定义相等是按照长度来定义的。相同长度的字符串的内容依然是有区别的。通过调用 `stable_sort` 可以保持相同长度的字符串的字典顺序：
````cpp
elimDups(words);
stable_sort(words.begin(), words.end(), isShorter);
````

### 10.3.2 lambda 表达式

传递给算法的谓词必须有一个或两个参数。但是有时我们想传递多于算法的谓词需要的参数。为了查找字符串序列中大于等于给定长度的字符串，我们写了一个函数：
````cpp
void biggies(vector<string> &words, vector<string>::size_type sz)
{
    elimDups(words);
    stable_sort(words.begin(), words.end(), isShorter);
    auto wc = find_if(words.begin(), words.end(), [sz](const string &a) {
        return a.size() >= sz;
    });
}
````
我们使用 `find_if` 标准库算法来查找一个元素大于等于给定长度的。`find_if` 接收一对迭代器表示输入范围，不同于 find 的是它接收的第三个参数是谓词。`find_if` 算法在每个元素上调用给定的谓词。它将返回第一个使得谓词的返回值为非 0 值的元素迭代器，或者当无法找到这样的元素时返回尾部迭代器。

由于 `find_if` 接收的是一元谓词，任何传递给 `find_if` 的函数必须只有一个参数。所以想要传递可变的 size 参数给谓词必须使用 lambda 表达式。

**介绍 lambda**

我们可以传递任何可调用对象（callable object）给算法。如果可以给对象或表达式运用调用操作符，它就是可调用的（callable）。也就是说如果 e 是可调用的表达式，那么可以写作 `e(args)` 其中 args 是一个逗号分隔的零个或多个参数的列表。

目前我们使用的可调用对象就是函数和函数指针。还有两种可调用对象：重载了调用操作符的类将在 §14.8 中介绍，以及现在将要介绍的 lambda 表达式（lambda expressions）。

lambda 表达式表示可调用的代码单元。可以被视作匿名内联函数。与任何函数一样，lambda 有返回类型，参数列表和函数体。与函数不同的是，lambda 可以被定义在函数中。其有如下形式：
````cpp
[capture list](parameter list) -> return type { function body}
````
其中捕获列表（capture list）（经常是空的）表示定义在外围函数中的一系列本地变量。返回值，参数列表和函数则与普通函数是一样的。然而，与普通函数不同的是，lambda 必须使用尾部返回（trailing return）来表示返回类型。

可以忽略参数列表和返回类型，但是必须总是包含捕获列表和函数体：
````cpp
auto f = [] { return 42; };
````
我们将 f 定义为一个不接受任何参数返回 42 的可调用对象。使用 lambda 的方式与任何函数调用都是一样的。如：
````cpp
cout << f() << endl;
````
省略 lambda 中的括号和参数列表表示其参数列表为空。如果省略返回值类型，lambda 通过函数体中语句进行推断。如果函数体中只有一个 return 语句，那么返回类型就是被返回的表达式的类型。否则，返回类型就是 void。

注意：lambda 中的函数体如果包含了除了返回语句之外的任何语句，都将被推断为返回 void。

**传递参数给 lambda**

与常规的函数调用一样，lambda 调用中的实参也是用于初始化其形参的。实参和形参的类型必须匹配。与常规函数不同的是，lambda 没有默认实参。因而，调用 lambda 给足实参。一旦形参被初始化，函数体就开始执行。

如下 lambda 需要传递参数：
````cpp
[](const string &a, const string &b) {
    return a.size() < b.size();
}
````
空的捕获列表表示不适用任何外围函数的本地变量。lambda 的参数与常规函数的参数一样是 `const string` 的引用。我们可以重写 `stable_sort` 的调用从而使用 lambda：
````cpp
stable_sort(words.begin(), words.end(),
    [](const string &a, const string &b) {
        return a.size() < b.size();
    });
````
当 `stable_sort` 需要比较元素值时，它将调用给定的 lambda 表达式。

**使用捕获列表**

注意上面使用的 `find_if` 中的 lambda 表达式中的捕获列表中的 sz。尽管 lambda 被定义在函数中，只有被指定了想要使用的外围函数本地变量才能使用。lambda 通过捕获列表来指定想要使用的变量。捕获列表中包含了 lambda 用于访问外围函数本地变量的信息。

这样 `find_if` 使用的 lambda 表达式捕获了 sz，并且只有一个参数，函数体中将给定 string 的长度与捕获值 sz 进行比较：
````cpp
[sz](const string &a) {
    return a.size() >= sz;
};
````
在 `[]` 中是逗号分隔的捕获列表，里边的名字是外围函数中定义的本地变量。由于这个 lambda 捕获了 sz，函数体就可以使用 sz，而没有捕获 words 就不能访问此变量。

注意：lambda 只能使用出现在捕获列表中的外围函数本地变量。

**`for_each` 算法**

`for_each` 算法有一个可调用对象并在输入范围内的每个元素上调用此对象。如：
````cpp
for_each(wc, words.end(), [](const string &s) { cout << s << " "; });
````
注意：这里并没有捕获 cout，捕获列表只用于捕获外围函数中定义的非静态变量。lambda 可以自由使用定义在函数外的变量，此处 cout 并不是一个本地变量；这个名字定义在 iostream 头文件中。只要包含了 iostream 头文件，这个 lambda 就可以使用 cout 。

捕获列表只用于捕获外围函数中定义的非静态变量；lambda 可以自由使用本地 static 变量或者定义在函数体外的变量。

### 10.3.3 lambda 捕获和返回

当我们定义 lambda 时，编译器为此 lambda 产生一个匿名的新类类型。在 14.8.1 节我们将看到这个类是怎样的。现在只需要知道当我们定义一个 lambda 时，我们同时定义了一个新类型和这个类型的对象：这个由编译器生成的类的匿名对象。

默认情况下，从 lambda 中生成的类包含有数据成员，这些数据成员与捕获列表中的变量一一对应。当 lambda 对象创建时其数据成员被初始化。

**值捕获**

与参数传递一样，可以通过值或引用捕获变量。目前我们使用到的是值捕获。值捕获中的变量必须是可拷贝的。与参数不同的是，捕获变量是在 lambda 创建时拷贝的，而不是在调用时：
````cpp
void fcn1()
{
    size_t v1 = 42;
    auto f = [v1] {return v1;};
    v1 = 0;
    auto j = f(); // j 是 42；在创建 f 是拷贝了 v1 的值；
}
````
由于在创建 lambda 时已经拷贝了值，因而接下来对捕获变量的修改不会影响 lambda 中对应的值。

以下是所有的捕获方式：

- `[]` 空的捕获列表。lambda 不适用外围函数中的变量；j
- `[names]` names 是逗号分隔的捕获列表。默认情况下，变量是值捕获的。在名字前加上 & 就是引用捕获；
- `[&]` 隐式引用捕获列表。在 lambda 函数体中所使用的外围函数的本地变量都被隐式地引用捕获；
- `[=]` 隐式值捕获列表。在 lambda 函数体中所使用的外围函数本地变量都被隐式地值捕获；
- `[&,identifier_list]` `identifier_list` 是逗号分隔的外围函数本地变量列表，这些变量是值捕获的，并且不能在名字前加上 &，其它的使用到外围本地变量是隐式引用捕获的；
- `[=,reference_list]` `reference_list` 是逗号分隔的外围函数的本地变量引用列表，这些变量是引用捕获的，所以必须在名字前加上 &，这个列表不能包括 this 指针。其它使用到的外围本地变量都是隐式值捕获的；

**引用捕获**

可以定义以引用捕获变量的 lambda，如：
````cpp
void fcn2()
{
    size_t v1 = 42;
    auto f2 = [&v1] { return v1; };
    v1 = 0;
    auto j = f2();
}
````
v1 前的 & 表示 v1 是引用捕获的。被引用捕获的变量与其它引用是一样的。当在 lambda 函数体中使用引用捕获的变量时，使用的是这个引用绑定的对象。这个例子中返回的 v1 其实是其绑定的外围函数中的本地变量的值。

使用引用捕获的变量跟常规的使用引用变量一样，当 lambda 被调用时需要确保引用捕获的变量确实存在。被 lambda 捕获的变量是本地变量，这些变量在函数完成时将消失。如果在函数结束后还可以调用 lambda ，那么将是严重的编程错误。

引用捕获有时是必须的，比如不可复制的对象：
````cpp
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ')
{
    for_each(words.begin(), words.end(), [&os, c](const string &s) { os << s << c; });
}
````

我们可以从函数中返回 lambda ，函数可以直接返回可调用对象或者函数返回一个具有可调用对象数据成员类对象。如果函数返回 lambda ，那么与函数不能返回本地变量的引用一样，这个 lambda 一定不能包含引用捕获。

警告：当我们进行引用捕获时，一定要保证当 lambda 执行时变量是存在的。

**建议：保持 lambda 的捕获尽量的简单**

lambda 捕获的信息在创建时保存，在执行时进行访问。保证这些信息的可用性是程序员自己的责任。按值的方式捕获 int ，string 和其它非指针变量是很简单的。这个时候，我们只需要关心在捕获时变量是否有我们需要的值。

如果捕获指针或迭代器或者按引用捕获，我们需要保证绑定到迭代器，指针和引用的对象在 lambda 执行时依然存在。甚至需要保证这个对象值是合理的。在 lambda 创建和执行之间的代码可能会改变按引用捕获的对象值。可能在创建时的值的确是我们想要的，但是当执行时其值已经变得很不一样了。

为了避免由捕获带来的问题尽可能缩小捕获的变量，并且尽可能避免捕获指针，迭代器和引用。

**隐式捕获**

相比于显式列举需要捕获的变量，可以让编译器对 lambda 函数体的代码进行推断。为了引导编译去推断捕获列表，我们在捕获列表中使用 `&` 或 `=`，其中 `&` 告知编译器按引用捕获，`=` 告知编译按值捕获。如以下是重写的 `find_if`：
````cpp
wc = find_if(words.begin(), words.end(), [=](const string &s) {
    return s.size() >= sz;
});
````
如果想让其中的一些变量按值捕获，可以昏庸隐式和显式捕获：
````cpp
for_each(words.begin(), words.end(), [&, c](const string &s) {
    os << s << c;
});
for_each(words.begin(), words.end(), [=, &os](const string &s) {
    os << s << c;
});
````

**Mutable Lambdas**

默认情况下，lambda 不会改变按值捕获的变量值，如果想要改变捕获变量的值，必须在参数列表后加上关键词 mutable。有 mutable 关键词的 lambda 不能省略参数列表：
````cpp
void fcn3()
{
    size_t v1 = 42;
    auto f = [v1] () mutable { return ++v1; };
    v1 = 0;
    auto j = f();
}
````
按引用捕获的对象是否可以改变仅仅依赖于引用的对象是 const 还是非 const 的：
````cpp
void fcn4()
{
    size_t v1 = 42;
    auto f2 = [&v1] { return ++v1; };
    v1 = 0;
    auto j = f2();
}
````

**指定 lambda 的返回类型**



### 10.3.4 绑定实参
## 10.4 再谈迭代器
### 10.4.1 插入迭代器
### 10.4.2 iostream 迭代器
### 10.4.3 反转迭代器
## 10.5 通用算法的分类
### 10.5.1 按照5种迭代器分类
### 10.5.2 按照算法的参数模式分配
### 10.5.3 算法名字的约定
## 10.6 特定于容器的算法
## 关键术语
