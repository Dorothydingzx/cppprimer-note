标准库容器定义了相当少的操作，与其添加无数的功能到每一个容器中，标准库提供了一系列算法，其中大部分独立于任何特定的容器类型。这些算法是通用的（generic）：它们在不同类型的容器和元素上进行操作。

本章的内容主要包括通用算法（generci algorithms）和更加详细的介绍迭代器。

顺序容器定义了简约的操作：其中大部分用于添加移除元素，访问首尾元素，判断容器是否为空，以及获取首元素和尾后元素的迭代器。

我们可以想象还需要其它有用的操作：查找特定的元素，替换或移除特定值，重排序容器中的元素。

与其将这些操作定义为每个容器类型的成员，标准库定义了一系列通用算法：“算法”意思是它们实现了常见的经典算法如排序和搜索，“通用”是由于它们操作与不同类型的元素以及跨越多种容器类型——不仅仅是标准库中的类型如 vector 和 list，还包括内置数组类型以及其它自定义的序列（sequences）类型。

## 10.1 概述

绝大部分算法定义在 algorithm 头文件中。标准库还在 numeric 头文件中定义了一小撮通用数字算法（generic numeric algorithms）。

通常来说，算法并不直接在容器上进行工作，而是通过遍历由两个迭代器组成的元素范围进行操作。当算法遍历整个范围时，它会对每个元素做一些事情。如要查找容器中的特定元素值最简单的方式是调用 find 算法：
````cpp
int val = 42;
auto result = find(vec.cbegin(), vec.cend(), val);
````
find 的前两个参数是两个迭代器，它们组成了一个左包含的元素范围，第三个参数是一个值。find 将给定范围中的每个元素与待查找的值进行比较。它返回第一个等于这个值的第一个元素的迭代器。如果没有找到，find 将返回其第二个参数来表示失败。因而，我们可以通过比较返回值是否与第二个迭代器参数相等来判断是否找到。

由于 find 仅对迭代器操作，可以将 find 用于任何的容器类型。如将 find 用于 `list<string>`：
````cpp
string val = "a value";
auto result = find(lst.cbegin(), lst.cend(), val);
````
由于内置数组中的指针与迭代器的行为非常类似，可以将 find 用于数组：
````cpp
int ia[] = {27,210,12,47,109,83};
int val = 83;
int* result = find(begin(ia), end(ia), val);
````
此处值得注意的是调用了库函数 begin 和 end 来获取 ia 的首元素指针和尾后元素指针。

通过传递子范围的首元素和尾后元素的迭代器（或指针）从而仅对容器的子范围进行查找。如：
````cpp
// 搜索元素从 a[1] 开始直到但不包括 ia[4]
auto result = find(ia+1, ia+4, val);
````

## 10.2 算法入门
### 10.2.1 只读算法
### 10.2.2 写容器元素的算法
### 10.2.3 对容器元素进行重排序的算法
## 10.3 定制操作
### 10.3.1 传递函数给算法
### 10.3.2 lambda 表达式
### 10.3.3 lambda 捕获和返回
### 10.3.4 绑定实参
## 10.4 再谈迭代器
### 10.4.1 插入迭代器
### 10.4.2 iostream 迭代器
### 10.4.3 反转迭代器
## 10.5 通用算法的分类
### 10.5.1 按照5种迭代器分类
### 10.5.2 按照算法的参数模式分配
### 10.5.3 算法名字的约定
## 10.6 特定于容器的算法
## 关键术语