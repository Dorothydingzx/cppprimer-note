标准库容器定义了相当少的操作，与其添加无数的功能到每一个容器中，标准库提供了一系列算法，其中大部分独立于任何特定的容器类型。这些算法是通用的（generic）：它们在不同类型的容器和元素上进行操作。

本章的内容主要包括通用算法（generci algorithms）和更加详细的介绍迭代器。

顺序容器定义了简约的操作：其中大部分用于添加移除元素，访问首尾元素，判断容器是否为空，以及获取首元素和尾后元素的迭代器。

我们可以想象还需要其它有用的操作：查找特定的元素，替换或移除特定值，重排序容器中的元素。

与其将这些操作定义为每个容器类型的成员，标准库定义了一系列通用算法：“算法”意思是它们实现了常见的经典算法如排序和搜索，“通用”是由于它们操作与不同类型的元素以及跨越多种容器类型——不仅仅是标准库中的类型如 vector 和 list，还包括内置数组类型以及其它自定义的序列（sequences）类型。

## 10.1 概述

绝大部分算法定义在 algorithm 头文件中。标准库还在 numeric 头文件中定义了一小撮通用数字算法（generic numeric algorithms）。

通常来说，算法并不直接在容器上进行工作，而是通过遍历由两个迭代器组成的元素范围进行操作。当算法遍历整个范围时，它会对每个元素做一些事情。如要查找容器中的特定元素值最简单的方式是调用 find 算法：
````cpp
int val = 42;
auto result = find(vec.cbegin(), vec.cend(), val);
````
find 的前两个参数是两个迭代器，它们组成了一个左包含的元素范围，第三个参数是一个值。find 将给定范围中的每个元素与待查找的值进行比较。它返回第一个等于这个值的第一个元素的迭代器。如果没有找到，find 将返回其第二个参数来表示失败。因而，我们可以通过比较返回值是否与第二个迭代器参数相等来判断是否找到。

由于 find 仅对迭代器操作，可以将 find 用于任何的容器类型。如将 find 用于 `list<string>`：
````cpp
string val = "a value";
auto result = find(lst.cbegin(), lst.cend(), val);
````
由于内置数组中的指针与迭代器的行为非常类似，可以将 find 用于数组：
````cpp
int ia[] = {27,210,12,47,109,83};
int val = 83;
int* result = find(begin(ia), end(ia), val);
````
此处值得注意的是调用了库函数 begin 和 end 来获取 ia 的首元素指针和尾后元素指针。

通过传递子范围的首元素和尾后元素的迭代器（或指针）从而仅对容器的子范围进行查找。如：
````cpp
// 搜索元素从 a[1] 开始直到但不包括 ia[4]
auto result = find(ia+1, ia+4, val);
````

**算法如何工作**

通过考察 find 算法来了解算法是如何运用于不同的容器类型的。find 可以在未排序的一系列元素中查找特定的元素。以下是它采取的步骤：

1. 访问序列的首元素；
2. 将其与给定值进行比较；
3. 如果这个元素匹配给定的值，find 将返回迭代器或者指针来标识这个元素；
4. 否则 find 继续查找下一个元素，重复步骤 2 和 3；
5. find 必须在到达序列的末尾时结束；
6. 如果 find 到了序列的末尾，需要返回一个值来表示元素没有找到。返回的值需要与第 3 步中的类型相兼容；

以上所有操作都没有依赖于容器的类型，只要能够使用迭代器来访问元素，find 根本不需要依赖于容器的类型。

**迭代器使得算法与容器互相独立**

除了第二步之外的所有步骤都可以通过迭代器进行操作：迭代器解引用可以访问元素；如果找到了匹配的元素，find 将返回那个元素的迭代器；迭代器的自增操作将移动到下一个元素；“尾后”迭代器表示 find 已经到达了给定序列的尾部；find 返回尾后迭代器用于表示没有找到指定的值；

**但是算法依赖于元素类型的操作**

尽管迭代器使得算法和容器类型相互独立，大部分的算法使用一个或多个元素类型的操作。如：第 2 步用元素类型的 `==` 操作符比较每个元素和给定值。

其它的算法需要元素类型由 `<` 操作符。然而，绝大部分的算法还提供了一种方式允许我们提供自己的操作用于替换默认的行为。

**关键概念：算法永不执行容器的操作**

通用算法自己不会执行容器的操作。它们只会操作迭代器。算法不直接调用容器的成员函数有一个重要的隐喻：算法永远不会改变底层容器的长度。算法可能会改变元素的值，可能会在容器中移动元素，但是它们不会直接添加或移除元素。

我们将在后面看到，有一种特殊类别的迭代器——插入器（inserter），除了遍历序列之外。当我们给这个迭代器赋值时，它将在底层容器中执行插入操作。当算法操作在这种迭代器上时，迭代器具有加元素到容器中的效果。但是算法本身不会插入元素，甚至它都不知道插入元素这回事。

## 10.2 算法入门
### 10.2.1 只读算法
### 10.2.2 写容器元素的算法
### 10.2.3 对容器元素进行重排序的算法
## 10.3 定制操作
### 10.3.1 传递函数给算法
### 10.3.2 lambda 表达式
### 10.3.3 lambda 捕获和返回
### 10.3.4 绑定实参
## 10.4 再谈迭代器
### 10.4.1 插入迭代器
### 10.4.2 iostream 迭代器
### 10.4.3 反转迭代器
## 10.5 通用算法的分类
### 10.5.1 按照5种迭代器分类
### 10.5.2 按照算法的参数模式分配
### 10.5.3 算法名字的约定
## 10.6 特定于容器的算法
## 关键术语
