C++ 的核心概念就是类。C++ 类定义构造函数来控制当类对象初始化时应该做什么。类同样可以定义函数来控制如何进行拷贝、赋值、移动和销毁。在这些方面 C++ 有别于其它语言，很多其它语言并不提供控制这些方面的基础设施。本章将介绍拷贝控制方面的知识，并且将引入新标准的两个概念：右值引用（rvalue reference）和移动操作（move operation）。

十四章则主要讲类类型如何进行操作符重载（operator overloading），使得类可以像内置类型一样使用内置操作符。其中值得注意的是调用操作符（function call operator），这样就可以像调用函数一样，对对象进行调用。并且将介绍新的库设施来简化不同类型的可调用对象，使其以统一的方式书写。最后还会讲特殊的成员函数——转换操作符（conversion operator），将定义从类对象到别的类型的转换。

写自己的面向对象或泛型需要对 C++ 有一个很好的理解，接下来几章的内容将是很高级的主题。

本章将学习类是如何控制当此类对象进行拷贝、赋值、移动和销毁时所做的事。类控制这些动作的成员函数分别是：拷贝构造函数（copy constructor）、移动构造函数（move constructor）、拷贝赋值操作符（copy-assignment operator）、移动赋值操作符（move-assignment operator）和析构函数（destructor）。

当我们定义类时，我们必须定义（不管是显式还是编译器生成）当对象被拷贝、移动、赋值或者销毁时发生的动作。其中拷贝、移动构造函数定义当对象由另外一个相同类型的对象进行初始化时发生的事。拷贝、移动赋值操作符定义当将类对象赋值给同类其它对象时发生的事。析构函数定义当对象消失时发生的事。以上这些操作被称为拷贝控制（copy control）。

如果类没有定义拷贝控制成员函数，编译器会自动定义这些函数。所以很多类可以忽略拷贝控制成员函数。然而，对于某些类来说，依赖于默认定义的拷贝控制会出问题。通常，实现拷贝控制操作最难的部分就是意识到什么时候需要自己定义这些函数。

拷贝控制是定义 C++ 类的非常重要的一部分。C++ 初学者通常对必须定义当发生拷贝、赋值、移动或销毁时的动作很疑惑。这个问题将变得更加复杂，因为，假如不定义的话，编译器会隐式定义这些函数，而且很有可能与我们的期望不符合。

## 13.1 拷贝、赋值和销毁

先从最基本的拷贝构造函数、拷贝赋值操作符和析构函数开始。

### 13.1.1 拷贝构造函数

只要是第一个参数是此类对象的引用并且所有其它参数都是默认值就是拷贝构造函数。其第一个参数必须是引用类型，并且几乎总是 const 引用类型，尽管也可以使用非 const 引用。拷贝构造函数将隐式用于不少场景下，因此，拷贝构造函数不应该是 explicit 的。

**合成构造函数**

当我们不定义拷贝构造函数时，编译器将自动合成一个。与默认构造函数不同的是，拷贝构造函数即使是在定义了其它构造函数时依然会合成。除非拷贝构造函数被定义为 delete 的（此时合成拷贝构造函数（synthesized copy constructor）将阻止拷贝该类的对象，尝试去调用将编译不通过），否则，合成构造函数将执行逐个成员拷贝（memberwiese copies）其参数的所有成员到被创建的对象中去，拷贝的顺序是按照在类中定义的顺序。

成员的类型决定了成员是如何进行拷贝的：类成员将调用其拷贝构造函数进行拷贝；内置类型成员则直接拷贝。尽管程序代码不能直接拷贝数组，编译器合成的拷贝构造函数通过拷贝其每一个元素来拷贝整个数组。类类型元素调用元素的拷贝构造函数进行拷贝。

**拷贝初始化**

当使用直接初始化时，编译器将使用常规的函数匹配来选择合适的构造函数以匹配程序员提供的参数。当使用拷贝初始化（copy initialization）时，编译器将右边操作数拷贝到正在创建的对象中，当需要时会对操作数进行转换。

拷贝初始化通常使用拷贝构造函数。如果一个函数有移动构造函数（move constructor），拷贝初始化在特定条件下将使用移动构造函数。

拷贝初始化不仅仅发生在定义变量时使用 `=`，也会出现在一下情形中：

- 以非引用方式传递对象给函数；
- 从函数中以非引用方式返回值；
- 括弧初始化数组中的元素或者聚合类；

有些类会使用拷贝初始化来构建其分配的动态对象，如容器初始化时提供的元素将被拷贝初始化，用 push 和 insert 方式插入的元素亦是拷贝初始化的。相反，用 emplace 的则是直接初始化的。

**参数和返回值**

函数调用中以非引用形式传递的参数是拷贝初始化的。同样，函数返回非引用类型的值，返回值将被用于初始化调用位置处的结果临时量。拷贝构造函数将被用于初始化非引用类型的参数解释了为何拷贝构造函数本身的参数必须是引用。

**编译器可以绕过拷贝构造函数**

在拷贝初始化中，编译器允许跳过拷贝/移动构造函数，而直接创建对象，这被称为拷贝消除（copy elision），也叫做返回值优化（Return Value Optimization（RVO）），调用函数直接在栈上给返回值分配内存，然后将其地址传递给被调用者，被调用者直接在这个空间上构建对象，从而消除了从里边往外边的拷贝需求。但是即便是编译器可以消除拷贝/移动构造函数的调用，这两个函数本身必须存在，并且时可访问的。
### 13.1.2 拷贝-赋值操作符

跟拷贝构造函数一样，如果没有定义拷贝赋值操作符，编译器会自动隐式合成一个。

**重载赋值操作符介绍**

重载操作符是一个函数，函数名字是 operator 后跟操作符的符号，重载赋值操作符就是 `operator=` ，操作符函数同样有返回值和参数列表。

重载操作符的参数表示操作符的操作数。其中一些操作符必须被定义为成员函数。当一个操作是成员函数，其做操作数被隐式绑定为 this 指针，而右操作数则作为参数显式传入。拷贝赋值操作符以相同类型的对象做为参数。

为了与内置类型的赋值操作符一致，重载赋值操作符通常返回其左操作数的引用。标准库要求存储在容器中的类对象有一个返回其左操作数的赋值操作符。

**合成拷贝赋值操作符**

如果类没有重载赋值操作符，编译器会合成拷贝赋值操作符（synthesized copy-assignment operator），与拷贝构造函数一样，一些类的合成拷贝赋值操作符会被定义为 delete ，从而禁用其赋值。否则，将使用每个所有非静态成员的拷贝赋值操作符将其从右边操作数赋值到左边操作数。数组成员以赋值每个成员的方式来赋值。合成的拷贝操作符返回其左操作数的引用。

### 13.1.3 析构函数

析构函数的作用域构造函数恰好相反：构造函数负责初始化所有非静态数据成员，并做一些别的工作；析构函数负责释放对象使用的资源，并且销毁其所有非静态数据成员。

析构函数的名字是 `~` 后接类名，其没有返回值，没有参数。由于其没有参数，所以不能被重载，一个类只有一个析构函数。

**析构函数所做的事**

析构函数分为两部份：函数体和析构部分。在构造函数中，成员先于函数体被初始化。在析构函数中，函数体先执行，然后成员按照在类定义中出现的相反顺序进行析构。

析构函数体可以执行类设计者需要对象在生命的最后阶段需要做的事，通常，析构函数体释放一个对象分配的资源。析构函数中没有对应于构造函数的初始化列表的部分来控制成员怎样被销毁。析构部分是隐式的，析构时发生什么将由成员的类型决定，类成员执行其自己的析构函数，内置类型成员则不执行任何析构操作。

特别是，动态分配的对象所返回的内置指针作为成员，在被析构时不会自动 delete 掉其指向的对象。与之不同的是，智能指针是类类型并且有析构函数。所以，智能指针将自动销毁其指向的动态对象。

**何时调用析构函数**

析构函数将在对象被销毁时自动调用，以下情况下将销毁对象：

- 变量离开作用域时将被销毁；
- 对象成员将在对象被销毁时跟着被销毁；
- 容器或数组中的元素将在其容器被销毁时跟着被销毁；
- 动态分配的对象将在 delete 时被销毁；
- 临时量将在其所在的整个表达式结束时被销毁；

由于析构函数是自动运行的，所以，程序可以分配资源并且不必考虑何时应该释放资源。析构函数不会在引用或者指向对象的指针离开作用域时自动运行。

**合成析构函数**

编译器为所有没有定义析构函数的类合成析构函数。与拷贝构造函数和拷贝赋值操作符一样，有些类的合成析构函数被定义为不允许类对象被析构。否则，合成析构函数的函数体是空的。

所有的成员都在函数体执行后自动销毁。值得指出的是析构函数体是不直接销毁其成员本身的。成员销毁是在析构函数体后的隐式析构部分进行销毁的。析构函数体与逐个成员析构一起构成销毁对象的过程。

### 13.1.4 三/五法则

以上介绍的是三个基本的拷贝控制的操作：拷贝构造函数、拷贝赋值操作符和析构函数。在新标准下，类还可以定义移动构造函数和移动赋值操作符。并不需要总是定义所有这些操作，可以定义其中一两个。但是通常这些操作需要被当作一个整体，仅仅只需要其中一个的情况很少发生。

**需要析构函数的类通常需要拷贝和赋值函数**

首要原则是如果一个类需要析构函数，那么几乎可以肯定需要拷贝构造函数和拷贝赋值操作符。通常，考察一个类是否需要析构函数是一个容易的事。通常一个类申请了资源，它就会需要一个析构函数。

**需要拷贝构造函数的通常意味着需要拷贝赋值操作符，反之一样**

一些类可以只定义拷贝和赋值对象所需要的操作函数，比如：每个对象都有自己的唯一 id 。所以，第二原则就是：如果一个类需要拷贝构造函数，它一定需要拷贝赋值操作符，并且相反是一样的。然而，需要这两者并不一定意味着需要析构函数。

### 13.1.5 使用 `=default`

当显式要求编译器为我们合成拷贝控制成员时，将它们定义为 `=default` 形式。当将 `=default` 放在类体中的声明处时，合成的函数隐式是内联的。如果不希望合成的成员是内联的，可以将 `=default` 放在成员定义处。只能将 `=default` 放在有合成版本的成员函数后。如：
````cpp
class Sales_data {
public:
    Sales_data() = default;
    Sales_data(const Sales_data&) = default;
    Sales_data& operator=(const Sales_data &);
    ~Sales_data() = default;
};
Sales_data& Sales_data::operator=(const Sales_data&) =default;
````

### 13.1.6 禁用拷贝

某些类并不需要拷贝控制函数，如：iostream 类。这些类必须定义成禁用拷贝控制函数。不定义这些函数是不行的，因为，编译器会隐式合成这些函数。

**将函数定义为 delete**

在新标准下可以通过将函数定义为被删除的函数（deleted functions），来禁用拷贝。被删除的函数是被声明但是不能被使用的函数。通过在函数后放置 `= delete` 来定义被删除的函数。被删除的函数不是未定义的函数，被删除的函数依然出现在函数匹配的候选函数中。但是，当其被选为最优函数时，将产生编译错误。

`=delete` 只能放在类定义内的成员函数声明处，不能放在定义处。原因在于，调用成员函数通常需要知道成员函数的声明。而类外的定义处则是生成函数代码的地方。

所有成员函数都可以被定义为被删除的函数。

**析构函数不应该被定义为被删除的函数**

如果将析构函数定义为被删除的，那么将毫无机会来销毁对象了。编译器将不允许程序定义这种类的变量或者创建临时量。并且，不能定义其成员类型有被删除的析构函数的类的变量或者临时量。尽管不能定义变量或者临时量，但是可以动态分配这种对象，除了不能删除这种动态对象。如：
````cpp
struct NoDtor {
    NoDtor() = default;
    ~NoDtor() = delete;
};
NoDtor *p = new NoDtor();
delete p; //错误!!不能删除这种对象
````

**合成的拷贝控制成员可能是被删除的**

对于某些类，编译器合成的拷贝控制函数是被删除的函数：

- 合成的析构函数是被删除的，如果类有一个成员，其析构函数是被删除的或者不可访问（private）；
- 合成的拷贝构造函数是被删除的，如果其成员自己的拷贝构造函数是被删除的或者不可访问。如果其成员的析构函数是被删除的或者不可访问；
- 合成的拷贝赋值操作符是被删除的，如果其成员的拷贝赋值操作符是被删除的或者不可访问，或者类有一个 const 或引用成员；
- 合成的默认构造函数是被删除的，如果其成员的析构函数是被删除的或者不可访问，或者有一个引用成员并且没有类内初始值，或者有一个 const 成员其类没有定义默认构造函数，并且没有类内初始值；

一句话概括，如果一个类的成员没有默认构造函数、拷贝、赋值、析构函数，那么对应的成员将是被删除的函数。

也许成员的析构函数被删除或不可访问将导致合成的默认和拷贝构造函数被定义为被删除的是令人诧异的，原因是，如果对象不能被销毁，那么它就不能被创建。

尽管可以给引用赋值，但是这样做将改变引用绑定的对象的值，如果为这样的类合成拷贝赋值操作符，那么左操作数将继续绑定相同的对象，它不会绑定到右操作数所绑定的对象。这种行为通常不是所希望的那样，所以，这种合成的拷贝赋值操作符将被定义为被删除的。

换一句话说，当一个类的成员不能被拷贝、赋值或销毁时，其对应的拷贝控制成员将被合成为被删除的。

**private 拷贝控制**

在新标准之前，类通过将拷贝构造函数和拷贝赋值操作符定义为 private 来阻止类被拷贝。由于拷贝构造函数和拷贝赋值操作符是 private 的，用户代码不能拷贝此对象。然而，友元和成员函数依然可以进行拷贝。为了阻止友元和成员对其进行拷贝，可以将拷贝控制成员声明为 private 的，并且不提供定义。只声明但是不定义一个成员函数是合法的，尝试去使用这个未定义的成员将导致链接错误。新标准中应当尽量使用 `=delete` 来阻止拷贝，而不是将成员声明为 private 的。

## 13.2 拷贝控制和资源管理

通常，如果类有自己管理的资源（动态分配的内存、网络、文件句柄等）肯定需要定义拷贝控制成员。这些类需要定义析构函数来释放资源。一旦其需要析构函数，那就意味着肯定需要拷贝构造函数和拷贝赋值操作符。

拷贝类对象有两个设计决定：以值的方式拷贝，以指针的方式拷贝。行为与值一样的类有其自己的状态，当拷贝这种对象时，拷贝后的对象与原始对象是互相独立的，对任何一方作出改变都不会影响到另外一方。行为与指针类似的类则共享状态，当拷贝这种对象时，原始对象和拷贝后的对象具有相同的底层数据。对任何一样的改变都会影响到另外一方。

通常，类直接拷贝内置类型成员，这些成员就是值，其行为与值是完全一样的。拷贝指针的不同方式将影响对象是值还是指针。

### 13.2.1 类像值一样

参考代码：[use_has_ptr.cc](https://github.com/chuenlungwang/cppprimer-note/blob/master/code/use_has_ptr.cc)

为了表现的像值一样，每个对象都有自己的一份资源拷贝。在 HasPtr 中，拷贝构造函数将拷贝 string 而不仅仅是字符串；析构函数将释放 string；拷贝赋值操作符将释放掉对象原有的 string 然后从右操作数中拷贝 string 过来。

**以值方式进行拷贝赋值操作符**

赋值操作符通常结合了析构函数和拷贝构造函数的行为。与析构函数一样，赋值操作将销毁其左边的操作数的资源。与拷贝构造函数一样，赋值将拷贝其右边操作数的数据。最重要的是，即便是对象给自己赋值行为亦必须是正确的。更重要的，应该保证赋值操作即便是在过程中抛出异常，其左操作数的状态是不变的。以先拷贝右边的值，然后再释放左边的数据，然后更新指针指向新分配的字符串，来保证安全进行赋值操作。

````cpp
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
    auto newp = new string(*rhs.ps);
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
````
在赋值操作符中，先执行构造函数的工作：newp 的初始化 HasPtr 的拷贝构造函数中的 ps 的初始化是一样的。与析构函数一样，然后 delete 掉 ps 当前指向的内存。剩下的就是将新的指针和 int 值拷贝到当前对象中。

当写赋值操作符的成员函数时，一个好的模式是先复制右操作数的资源到一个临时量中。在拷贝之后，就可以安全的释放掉左操作数中的数据。最后将临时量中的数据拷贝到左操作数中。

### 13.2.2 定义类像指针一样

参考代码：[use_has_ptr2.cc](https://github.com/chuenlungwang/cppprimer-note/blob/master/code/use_has_ptr2.cc)

最好的将类定义为表现地与指针一样的方式是使用 `shared_ptr` 来管理资源。

偶尔希望直接管理资源时需要自己定义引用计数（reference count），倾向于将引用计数器放在动态内存中，每个对象保留一个指向这个计数器的指针。

其拷贝赋值操作符同时做了拷贝构造函数和析构函数的工作。赋值操作符将增加右操作数的引用计数（拷贝构造函数的工作）并减少左操作数的引用计数，当引用计数变为 0 的时候删除掉其内存（析构函数的工作）。

## 13.3 交换

除了定义拷贝控制成员外，需要管理资源的类通常还会定义 swap 函数。定义 swap 函数对于希望改变元素的顺序的算法来说特别重要。这种算法在需要交换元素的顺序时调用 swap 函数。如果一个类定义了自己的 swap 函数，算法将使用类定义的版本。否则，将使用库中定义的版本，这个版本在概念上会执行一次拷贝和两次赋值。这样的定义需要多次拷贝值，如果是程序员自己定义的版本，那么只需要交换其中的指针即可。如：
````cpp
class HasPtr {
    friend void swap(HasPtr&, HasPtr&);
};
inline void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
````
定义 swap 函数并不是必须的，然而定义 swap 是对分配了资源的类的重大优化。

**swap 成员函数应该调用 swap，而不是 std::swap**

在 swap 函数中应该调用 swap 函数而不是 std::swap ，原因在于，不加修饰的 swap 可能会调用特定于成员类型的版本。如果有一个类型特定的 swap 函数，那个版本将会优于 std 下的 swap 函数，如此，如果有特定版本将会调用这个特定版本，如果没有将会调用标准版本。

**在赋值操作符中使用 swap**

定义了 swap 函数的类经常将 swap 用于定义赋值操作符，这种定义方式被称为拷贝-交换（copy and swap），将其左操作数与右操作数的一个拷贝进行交换。如：
````cpp
HasPtr& HasPtr::operator=(HasPtr rhs)
{
    swap(*this, rhs);
    return *this;
}
````
需要注意的是 rhs 是按值传递的，因而，rhs 是调用拷贝构造函数构建的。而 swap 函数将这个本地变量与左操作数进行交换，最后这个本地变量被销毁，使得旧数据被释放。

使用拷贝交换的赋值操作是自动异常安全的，并且可以正确处理自我赋值。

## 13.4 拷贝控制实例

参考代码：[message.cc](https://github.com/chuenlungwang/cppprimer-note/blob/master/code/message.cc)

## 13.5 管理动态内存的类

一些类需要分配不定数量的内存，这种类最好是用库容器来装载数据。然而，这种策略并不适合于所有类，有些类需要自己分配数据。这些类通常定义自己的拷贝控制成员来管理内存分配。

参考代码：[StrVec.cc](https://github.com/chuenlungwang/cppprimer-note/blob/master/code/StrVec.cc)

当调用 reallocate 时，并不需要将就数据中的字符串拷贝到新的数据中，原因是旧数据马上就要被丢弃了，此时应该移动而不是拷贝这个数据，这样就避免了给字符串重新分配内存。

**移动构造函数和 std::move**

通过移动构造函数可以将给定对象的资源移动到将要被构建的对象中去。移动构造函数将保证被移动的对象，其内部状态是可以被有效的析构的。如：指针变为空指针。

同时标准库中定义了一个新函数 `std::move` 在 utility 头文件中。使用 move 函数有两点需要注意：1. 如果希望调用移动构造函数需要调用 `std::move` 来告诉编译器使用移动构造函数，否则，将会使用拷贝构造函数。2. 调用 move 必须加上作用域限定符，显式告诉编译器我们调用的是哪个版本的函数；如：
````cpp
alloc.construct(dest++, std::move(*elem++));
````
调用 move 将返回一个结果，这个结果将导致 construct 函数使用 string 的移动构造函数。由于使用了移动构造函数，由这些 string 管理的内存将不会被拷贝。相反，新构建的 string 将获取旧 string 的所有权。在移动元素之后，就可以将旧的元素给 free 掉了，移动构造函数将保证可以安全的将 string 析构掉或者被赋予新的值。

## 13.6 移动对象
### 13.6.1 右值引用
### 13.6.2 移动构造函数和移动赋值
### 13.6.3 右值引用和成员函数
## 关键术语