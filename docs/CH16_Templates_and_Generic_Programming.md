面向对象（OOP）和泛型编程（generic programming）都是处理在书写程序时未知的类型，所不同的是 OOP 处理直到运行时才知道的类型，而泛型编程则处理知道编译时才知道的类型。

当书写泛型程序时，写出来的代码与特定类型是独立的。当使用泛型程序时则需要提供类型或者值（作为泛型实参）给泛型代码。

模板（Template）是泛型编程的基石，使用模板并不需要太多关于模板的知识。在本章将学习如何定义自己的模板。

模板是 C++ 中的泛型编程的基石。模板是编译器生成类和函数的蓝本（blueprint）或公式（formula），当使用泛型类型（generic type）或者泛型函数（generic function）时，必须提供必要的信息从而将蓝本转换为特定的类或函数，转换过程发生在编译期间。

## 16.1 定义模板

为每个类型都定义相同的操作是十分繁琐的，而且需要知道所有操作的类型，更合理的方式是定义函数模板，然后在使用时提供类型即可。参考代码：[template.cc](https://github.com/chuenlungwang/cppprimer-note/blob/master/code/template.cc)。

### 16.1.1 函数模板

相比于为每个类型定义一个新的函数，可以定义函数模板（function template）。函数模板是合成特定类型版本的蓝本。如：
````cpp
template <typename T>
int compare(const T &v1, const T &v2)
{
    if (std::less<T>()(v1, v2)) return -1;
    if (std::less<T>()(v2, v1)) return 1;
    return 0;
}
````
模板定义从关键字 template 开始，后面跟着模板参数列表（template parameter list），这是放在尖括号中的一个逗号分隔的一个或多个模板参数（template parameters）。

在模板定义中，模板参数列表不能是空的。

模板参数列表与函数参数列表类似，模板参数表示在类或函数定义中使用到类型或值。当使用模板时，通过隐式或显式的方式将模板实参（template argument）绑定到模板参数。

以上的 compare 函数声明了一个类型参数 T，在 compare 内部，使用 T 来表示一个类型，T 真正表示什么类型将在编译期间由其是如何使用决定的。

**实例化函数模板**

当调用函数模板时，编译器使用调用实参来推断模板实参。编译器使用实参的类型来决定绑定到模板参数 T 上的类型。通常函数模板是通过推断得到的，不需要显式提供，而且可能推断出来的类型与调用实参的类型并不一样。如：
````cpp
cout << compare(1, 0) << endl;
````
这里实参的类型是 int，编译器将 int 推断为模板实参，并且将此实参绑定到模板参数 T 上。编译器使用推断的模板参数来实例化（instantiate）一个特定版本的函数。当编译器实例化一个模板时，乃是使用模板实参替换对应的模板参数来创建一个模板的新“实例”。如还可以做一下调用：
````cpp
vector<int> vec1{1,2,3}, vec2{4,5,6};
cout << compare(vec1, vec2) << endl;
````
将实例化一个版本，其中 T 被 `vector<int>` 替换。这些编译器生成的函数被统称为模板的实例（instantiation）。

**模板类型参数**

compare 函数具有一个模板类型参数（template type parameter），通常，可以将类型参数当作一个类型说明符（type specifier）来使用，这与使用内置类型或类类型是一样的。特别是，类型参数可以被使用于返回类型或函数参数类型，或者变量声明以及强转时的类型。如：
````cpp
template <typename T> T foo(T* p)
{
    T tmp = *p;
    return tmp;
}
````
每个类型参数都可以被放在关键字 class 或 typename 之后。class 与 typename 在这种情况下是完全一样的，且可以互换。而使用 typname 关键字是一个更加直观的方式，毕竟可以使用内置类型作为模板类型实参，而且 typename 更加清晰地告知后面跟随的名字是类型名字。然而，当 typename 被添加到 C++ 语言时，模板已经被广泛运用了；一些程序员依然在继续使用 class 关键字。

**非类型模板参数**

除了可以定义类型参数，还是可以定义带有非类型参数（nontype parameters）的模板。非类型参数表示一个值而不是类型。非类型参数通过使用特定类型名字而不是 class 或 typename 来指定。当模板被实例化时，非类型参数将被一个用户提供的值或者编译器推断的值替代。这些值必须是常量表达式（constant expressions），只有这样编译器才能在编译期间实例化模板。如：
````cpp
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    cout << N << std::endl;
    cout << M << std::endl;
    return strcmp(p1, p2);
}
compare("hi", "mom");
````
编译器将会使用字面量的长度替换 N 和 M 非类型参数来实例一个模板版本。上面将被实例化为：
````cpp
int compare(const char (&p1)[3], const char (&p2)[4]);
````
一个非类型参数可能是整数类型、函数或对象的指针或左值引用。绑定到整型的实参必须是常量表达式；绑定到指针或引用的实参必须具有静态生命周期（static lifetime），不能使用常规本地对象或动态对象的地址或引用作为实参，指针参数还可以被实例化为 nullptr 或零值常量表达式；

模板的非类型参数在模板定义中是一个常量值。一个非类型参数可以在需要常量表达式的时候使用，如：作为数组的长度。

提供给非类型模板参数的模板实参必须是常量表达式。

**内联（inline）和 constexpr 函数模板**

函数模板可以与常规函数一样被声明为 inline 或 constexpr 的，inline 或 constexpr 关键字放在模板参数列表后，在返回类型前：
````cpp
template <typename T> inline T min(const T &, const T &);
````

**书写类型无关（Type-Independent）的代码**

如 compare 函数中使用 `const T &` 作为参数，那么可以传递任何类型的参数进去，扩大了函数的使用范围。而内部都使用 `less<T>` 可调用对象，less 对象可以处理好指针不是指向同一个数组的情况，若用 `<` 得到的结果将是未定义的（undefined）。

模板程序应该尽可能的减少对实参类型的要求。

**模板编译**

编译器并不是遇到模板定义时生成代码，而是在实例化特定版本的模板时生成代码。当使用模板时才生成代码将影响到如何组织源代码和错误何时被发现。

通常，调用函数时编译器只要看到函数的声明即可。使用类对象时，编译器需要知道类的定义（class definition）和成员函数的声明，而不需要成员函数的定义，因而，将类定义和函数声明放在头文件中，而函数定义或类成员函数定义则放在源文件中。

不过模板却有不同：为了生成实例，编译器需要知道函数模板的定义以及类模板成员函数（class template member function）的定义。因而，与非模板代码不同，模板代码的头文件中通常包含声明和定义。

函数模板和类模板的成员函数定义通常放在头文件中。

**关键概念：模板和头文件**

模板包含两种类型的名字：与模板参数无关的、与模板参数有关的。

模板提供者需要保证所有与模板参数无关的名字在模板被使用时是可见的。另外，模板提供者必须保证模板的定义（包括类模板成员定义）在模板被实例化时是可见的；

保证声明所有与实例化模板的类型参数相关的函数、类型和操作符是可见的，如：模板类型参数的成员函数、操作符重载以及内部定义的类型。

模板提供者应该将所有模板定义和定义模板时用到的名字声明都放在头文件中。模板的用户使用时必须包含模板头文件以及用于实例化模板的类型的头文件。

### 16.1.2 类模板
### 16.1.3 模板参数
### 16.1.4 成员模板
### 16.1.5 控制实例化
### 16.1.6 效率和灵活性

## 16.2 模板实参推断
### 16.2.1 转换和模板类型参数
### 16.2.2 函数模板显示实参
### 16.2.3 尾部返回类型和类型转换
### 16.2.4 函数指针和实参推断
### 16.2.5 模板实参推断和引用
### 16.2.6 理解 `std::move`
### 16.2.7 Forwarding

## 16.3 重载和模板

## 16.4 可变参数模板
### 16.4.1 书写可变参数函数模板
### 16.4.2 包扩展（Pack Expansion）
### 16.4.3 转发参数包（Forwarding Parameter Packs）

## 16.5 模板特例化

## 关键术语