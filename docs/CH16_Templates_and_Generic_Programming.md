面向对象（OOP）和泛型编程（generic programming）都是处理在书写程序时未知的类型，所不同的是 OOP 处理直到运行时才知道的类型，而泛型编程则处理知道编译时才知道的类型。

当书写泛型程序时，写出来的代码与特定类型是独立的。当使用泛型程序时则需要提供类型或者值（作为泛型实参）给泛型代码。

模板（Template）是泛型编程的基石，使用模板并不需要太多关于模板的知识。在本章将学习如何定义自己的模板。

模板是 C++ 中的泛型编程的基石。模板是编译器生成类和函数的蓝本（blueprint）或公式（formula），当使用泛型类型（generic type）或者泛型函数（generic function）时，必须提供必要的信息从而将蓝本转换为特定的类或函数，转换过程发生在编译期间。

## 16.1 定义模板

为每个类型都定义相同的操作是十分繁琐的，而且需要知道所有操作的类型，更合理的方式是定义函数模板，然后在使用时提供类型即可。参考代码：[template.cc](https://github.com/chuenlungwang/cppprimer-note/blob/master/code/template.cc)。

### 16.1.1 函数模板

相比于为每个类型定义一个新的函数，可以定义函数模板（function template）。函数模板是合成特定类型版本的蓝本。如：
````cpp
template <typename T>
int compare(const T &v1, const T &v2)
{
    if (std::less<T>()(v1, v2)) return -1;
    if (std::less<T>()(v2, v1)) return 1;
    return 0;
}
````
模板定义从关键字 template 开始，后面跟着模板参数列表（template parameter list），这是放在尖括号中的一个逗号分隔的一个或多个模板参数（template parameters）。

在模板定义中，模板参数列表不能是空的。

模板参数列表与函数参数列表类似，模板参数表示在类或函数定义中使用到类型或值。当使用模板时，通过隐式或显式的方式将模板实参（template argument）绑定到模板参数。

以上的 compare 函数声明了一个类型参数 T，在 compare 内部，使用 T 来表示一个类型，T 真正表示什么类型将在编译期间由其是如何使用决定的。

**实例化函数模板**

当调用函数模板时，编译器使用调用实参来推断模板实参。编译器使用实参的类型来决定绑定到模板参数 T 上的类型。通常函数模板是通过推断得到的，不需要显式提供，而且可能推断出来的类型与调用实参的类型并不一样。如：
````cpp
cout << compare(1, 0) << endl;
````

### 16.1.2 类模板
### 16.1.3 模板参数
### 16.1.4 成员模板
### 16.1.5 控制实例化
### 16.1.6 效率和灵活性

## 16.2 模板实参推断
### 16.2.1 转换和模板类型参数
### 16.2.2 函数模板显示实参
### 16.2.3 尾部返回类型和类型转换
### 16.2.4 函数指针和实参推断
### 16.2.5 模板实参推断和引用
### 16.2.6 理解 `std::move`
### 16.2.7 Forwarding

## 16.3 重载和模板

## 16.4 可变参数模板
### 16.4.1 书写可变参数函数模板
### 16.4.2 包扩展（Pack Expansion）
### 16.4.3 转发参数包（Forwarding Parameter Packs）

## 16.5 模板特例化

## 关键术语