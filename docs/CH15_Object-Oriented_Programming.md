面向对象变量建立三大概念上：数据抽象（data abstraction）、继承（inheritance）和动态绑定（dynamic binding）。继承和动态绑定在两个方面影响如何写程序：使得定义类似但不相同的类更加容易，使得用户代码可以相同的方式调用它们而忽略其中的差异。

很多应用包含相关但是有略微不同的概念。面向对象编程（OOP）刚好非常适合这种应用。

## 15.1 面向对象：介绍

面向对象编程（object-oriented programming）的关键思想在于数据抽象、继承和动态绑定。使用数据抽象，可以将类的接口和实现进行分离。通过继承，可以定义概念上相互关联且类型相似的类。通过动态绑定，可以在使用这些对象时忽略它们的细节上的不同。

**继承**

通过继承关联起来的类组成了层级。通常层级的顶端是一个基类（base class），其它类直接或间接的继承之，这些继承的类称之为派生类（derived classes）。基类定义层级中所类型都共通的成员，每个派生类定义特定于派生类自己的成员。如 [Quote.cc](https://github.com/chuenlungwang/cppprimer-note/blob/master/code/Quote.cc) 中的 isbn() 函数在基类中定义，因为，这是在整个层级都共通的成员，而派生类定义自己的 `net_price(size_t)` 函数，因为每个类有其自己的不同策略，需要 Quote 和 Bulk_qute 类定义自己的版本。

在 C++ 中，基类区分了每个类具有不同实现的函数与希望派生类只继承而不能做出改变的成员函数。基类将希望派生类定义自己的版本的函数为 `virtual` 的。

派生类需要指定其继承的类，指定方式使用类继承列表（class derivation list），即冒号后跟着一列由逗号分隔的基类，每个基类有一个可选的访问说明符（access specifier）。如：
````cpp
class Bulk_quote : public Quote {
public:
    double net_price(std::size_t) const override;
};
````
由于 Bulk_quote 在派生列表中使用 public ，就可以像使用 Quote 一样使用 Bulk_quote ，派生类必须在其类体中声明所有其想定义自己版本的基类虚函数。派生类可以在这些函数上包含 virtual 关键字，但不是必需的。新标准允许派生类通过在参数列表后包含 override 关键字，来显式说明成员函数是覆盖其继承的一个虚函数。

**动态绑定**

通过动态绑定，可以使用相同的代码来平滑处理基类和派生类对象，在这里是 Quote 和 Bulk_quote 。示例代码：
````cpp
double
print_total(std::ostream &os, const Quote &item, std::size_t n)
{
    double ret = item.net_price(n);
    os << "ISBN: " << item.isbn()
       << " # sold: " << n << " total due: " << ret << std::endl;
    return ret;
}
````
由于 item 是 Quote 的引用，调用函数时既可以传递 Quote 对象也可以传递 Bulk_quote 对象，并且由于 net_price 是虚函数，由于调用 net_price 函数是通过引用，具体调用哪个版本的函数，将依据传入对象的类型决定。如果传入 Bulk_quote 的对象则调用 Bulk_quote 的版本，如果传入 Quote 类的对象，则调用 Quote 的版本。

由于调用哪个版本是由实参的类型决定的，而实参类型只有在调用时才能知道。因而，动态绑定有时也被称为运行时绑定（run-time binding）。

在 C++ 中，动态绑定发生在虚函数通过基类的引用或指针调用时。

## 15.2 定义基类和子类

在绝大多数情况下，定义基类和派生类的方式与其它类是差不多的。

### 15.2.1 定义基类

作为继承层次的根类总是定义虚析构函数。基类通常应该定义虚析构函数，即便不做任何工作，虚析构函数依然是需要的。

**成员函数和继承**

派生类从其基类中继承成员，然而，派生类需要为特定于类型的操作提供自己的函数定义。派生类需要覆盖（override）掉其从基类继承来的定义，并提供自己的定义。

C++ 的基类必须明确区分希望派生类覆盖的函数和希望派生类继承而不改变的函数。基类将希望派生类覆盖的函数定义为 virtual 的。通过指针或引用调用虚函数，这个调用将是动态绑定的。根据引用或指针绑定的不同对象类型，基类或者其中之一的派生类的虚函数版本将被调用。

基类通过在声明前加上关键字 virtual 来指明成员函数是动态绑定的。所有的非静态成员函数（除了构造函数）都可以是 virtual 的。virtual 关键只出现在类体内的函数声明处，而不会被用于类体外的函数定义处。在基类中被定义为 virtual 的函数，其在派生类中隐式也是 virtual 的。

没有被定义为 virtual 的成员函数将在编译时确定下来，而不是运行时。如：`isbn` 函数只有一份定义，不论是以引用、指针还是对象值进行调用，都可以在编译时确定调用哪个函数，即 Quote 中的版本。

**访问控制和继承**

派生类继承基类中的所有成员，但这并不意味着派生类可以访问基类中的所有成员。与其它使用基类的代码一样，派生类可以使用基类的 public 成员，但是不能访问基类的 private 成员。基类将只允许派生类访问，而不允许其它用户代码访问的成员定义为 protected。

### 15.2.2 定义子类

派生类必须指定从哪个类继承，这是通过类继承列表（class derivation list），即冒号后的一列由逗号分隔的类名字，类必须是在之前定义过的（可以是未完成类型 incomplete type）。每个基类名字前可以放置可选的访问说明符，必须是 public 、 protected 或 private 中的一个。

派生类必须将所有要覆盖的继承来的成员函数进行类内声明。因而，Bulk_quote 类必须包含 net_price 的成员函数声明。

继承列表中的访问说明符将决定派生类的用户代码是否可以知道派生类从哪个基类继承而来。当继承是 public 的，基类的 public 成员变成了派生类的接口的一部分。并且，可以将公共派生的类型对象绑定到基类的指针或引用。

绝大多数类只会直接从一个基类继承，这种形式的继承称之为单继承（single inheritance），在 18 章将描述继承列表中包含多于一个基类的继承。

**派生类中的虚函数**

派生类经常但不总是覆盖其继承的虚函数。如果派生类不覆盖其基类的虚函数，那么与别的成员一样，派生类将继承基类中定义的版本。

派生类将在其覆盖的函数上包含 virtual 关键字，但是不是必须这么做。新标准允许派生类显式告知它将覆盖一个继承自基类的虚函数。它是通过在参数列表后指定 override 关键字，或者如果成员函数是 const 的或者有引用修饰符，那么就放在 const 或引用修饰符后。

**派生类对象和派生类到基类的转换**

一个派生类对象包含多个部分：包含派生类自己定义的成员的子对象，加上每一个基类的子对象。如：`Bulk_quote` 类的对象包含两个部分：自己定义的成员组成的子对象，与基类 `Quote` 子对象。由于派生类对象包含每个基类对应的子对象，可以把派生类对象当作基类对象一样使用，特别是，可以将基类对象的引用或指针绑定到派生对象的基类部分。如：
````cpp
Quote item;
Bulk_quote bulk;
Quote *p = &item;
p = &bulk;
Quote &r = bulk;
````
这种转换称为派生类到基类的转换（derived-to-base conversion），这种转换是由编译器隐式执行的。由于这种转换是隐式的，可以将派生类对象或派生对象的引用用于需要基类对象引用的地方。同样的，可以将派生类对象的指针用于需要基类指针的地方。

派生类对象包含其基类的子对象是理解继承如何工作的关键。

**派生类构造函数**

尽管派生对象包含从基类继承来的成员，它不能直接初始化这些成员。与任何别的创建基类对象的代码一样，派生类必须使用基类构造函数来初始化基类部分。

每个类的构造函数控制其成员如何进行初始化。

对象的基类部分与派生类的数据成员一起在构造函数的初始化阶段进行初始化。与初始化成员一样，派生类构造函数使用构造初始值列表来传递参数给基类构造函数。如：
````cpp
Bulk_quote(const std::string &book, double p, std::size_t qty, double disc):
    Quote(book, p), min_qty(qty), discount(disc) { }
````
当基类函数的整个函数体执行完之后，将执行数据成员的初始化，然后执行派生构造函数体。

与数据成员一样，除非是另外指定，派生类的基类部分是默认初始化的。为了调用不同的基类构造函数，可以在构造初始值中使用基类名字跟上一个参数列表，这些参数被用于选择使用哪个基类构造函数用于初始化派生对象的基类部分。

基类对象总是先初始化，然后是派生类的数据成员根据在类体中声明的顺序进行初始化。

**在派生类中使用基类成员**

派生类可以访问基类的 public 和 protected 成员。派生类的作用域被嵌套在基类的作用域中，那么在派生类成员函数中使用派生类自己定义的成员和使用基类中定义的成员没有区别。

**关键概念：尊重基类的接口**

理解每个类定义自己的接口是很重要的，与类对象进行交互时应该使用那个类的接口，即便那个对象是派生对象的基类部分。因而，派生类构造函数不会直接初始化基类的成员。派生构造函数的函数体可以给 public 和 protected 基类成员进行赋值。尽管它可以这样做，通常不应该这样做。与任何别的使用基类的用户代码一样，派生类应该尊重其基类的接口，所以应该使用基类的构造函数来初始化其继承的成员。

**继承和静态成员**

如果在基类中定义了静态成员，那么整个继承层级中只有此成员的唯一定义。不管从一个基类中派生了多少类，每个静态成员只存在一份实例。如：
````cpp
class Base {
public:
    static void statmem();
};
class Derived : public Base {
    void f(const Derived &);
};
````
静态成员遵循常规的访问控制。如果一个成员在基类中是 private 的，那么派生类将无法访问它。如果成员是可访问的，则可以基类或派生类中使用此 static 成员。如：
````cpp
void Derived::f(const Derived &derived_obj)
{
    //可以通过基类访问
    Base::statmem();
    //可以通过派生类访问
    Derived::statmem();
    //可以通过派生对象访问基类中的静态成员
    derived_obj.statmem();
    //可以通过当前对象访问
    statmem();
}
````

**声明派生类**

派生类的声明与常规类的声明是一样的。声明中包含类的名字，但不包含派生列表。如：
````cpp
class Bulk_quote : public Quote; //错误：声明类中不能出现派生列表
class Bulk_quote; //正确的声明派生类的方式
````
声明的目的在于让程序知晓某个名字的存在以及它表示什么类型的实体，如：类、函数或变量。派生列表和所有其他的定义细节必须一起出现在类体中。

**被用作基类的类**

一个类在被用作基类之前必须定义而不能仅仅只声明。原因在于，每个派生类都包含并且可能使用其从基类继承来的成员。为了使用这些成员，派生类必须知道它们具体是什么。这也隐式说明一个类不能派生它本身。

一个类是基类，同时它是一个派生类。如：
````cpp
class Base {};
class D1 : public Base {};
//D1 既是基类也是派生类
class D2 : public D1 {};
````
在这个层级中，Base 是 D1 的直接基类（direct base），是 D2 的间接基类（indirect base）。直接基类被放在派生列表中，间接基类是派生类通过其直接基类继承来的。

每个类都继承其直接基类的所有成员。最具体的派生类将继承其直接基类的所有成员，直接基类中的成员包含它自己从它的基类中继承来的成员，以此类推到整个继承链的顶端。所以，最具体的派生对象将包含其直接基类的子对象以及每个间接基类的子对象。

**阻止继承**

有时我们不希望一个类被继承，在新标准中可以通过在类名后加上 final 来阻止类被当作基类。如：
````cpp
class NoDerived final {};
class Base {};
class Last final : public Base {}
````

### 15.2.3 转换和继承

理解派生类到基类的转换时理解 C++ 中面向对象编程的关键。通常，只能将引用和指针绑定到有相同类型的对象上，或者绑定到可以进行 const 转换的对象上。存在继承关系的类时一个例外：可以将基类的指针或引用绑定到这个类的派生对象上。

这个事实有很重要的暗示：当使用基类的引用或指针时，不知道绑定的对象的真实类型是什么，这个对象可能是基类对象，也可能是派生类对象。而且与内置指针一样，智能指针也支持派生类到基类的转换，可以将指向派生对象的指针存储到基类的智能指针。

**静态类型和动态类型**

当使用存在继承关系的类时，应该区分变量或表达式的静态类型（static type）以及其背后的动态类型（dynamic type）。表达式的静态类型在编译时就是已知的，它是变量声明时的类型或者表达式的结果类型。动态类型是变量或表达式所表示的在内存中的真正对象的类型，这个类型必须到运行时才能知道。如：
````cpp
double ret = item.net_price(n);
````
item 的静态类型是 Quote&，动态类型则依据绑定到 item 的参数类型，这个类型直到运行时才能知道。如果传递 Bulk_quote 那么 item 的静态类型与动态类型将不一样，此时，item 的静态类型是 Quote& ，而其动态类型是 Bulk_quote 。

既不是引用也不是指针的表达式的静态类型和动态类型是一样的。理解基类的指针或引用的静态类型和动态类型不一样是至关重要的。

**没有从基类到派生类的隐式转换**

从派生类到基类的转换是因为每个派生对象都包含基类部分，这个部分可以被基类的指针或引用绑定。基类对象可以独立存在，也可以作为派生对象的一部分。一个非派生类一部分的基类对象只包含基类定义的成员，并不包含派生类定义的成员。所以，并不存在从基类到派生类的自动转换。如：
````cpp
Quote base;
Bulk_quote *bulkP = &base; //错误：不能将基类转为派生类
Bulk_quote &bulkRef = base; //错误：不能将基类转为派生类
````
如果以上赋值是合法的，那么将在 bulkP 或 bulkRef 中使用 base 中不存在的成员。有一点令人惊奇的是，即便基类指针或引用绑定到派生对象，其依然不能转为派生类。如：
````cpp
Bulk_quote bulk;
Quote *itemP = &bulk;
Bulk_quote *bulkP = itemP; //错误：不能将基类转为派生类
````
编译器没有在编译时以任何方式知道从基类转为派生类是否是安全的。编译器只能依据指针或引用的静态类型来判断转换是否是合法的。如果基类有一个或多个虚函数，可以使用 dynamic_cast 来请求带运行时检查的转换。同样，在确实知道从基类到派生类的转换是安全的，可以使用 static_cast 类覆盖掉编译器的规则。

**对象间不存在转换**

派生类到基类的自动转换只发生于引用或指针类型。从派生对象到基类对象是不存在转换的。然而，从表现上看经常可以将派生对象转为基类，只是这和引用、指针的那种派生类到基类的转换是不一样的。

当初始化一个类对象时，将调用构造函数。当赋值时将调用赋值操作符。这些成员函数通常具有一个该类对象的 const 引用的参数。由于其参数接收引用，派生类到基类的转换允许我们传递一个派生对象给基类的拷贝/移动操作成员函数。这些操作并不是 virtual 的。当传递派生对象给基类构造函数时，基类中定义的构造函数将被执行。那个构造函数只能识别基类自己定义的成员，类似的，如果将一个派生对象赋值给基类对象，基类中定义的赋值操作符将被执行。那个操作符只能识别基类中定义的成员。由于派生类部分被忽略了，所以派生类部分被裁剪（sliced down）掉了。

当用派生对象去初始化或赋值基类对象时，只有基类部分被拷贝、移动或赋值，派生类部分将被忽略。

## 15.3 虚函数
## 15.4 抽象基类
## 15.5 访问控制与继承
## 15.6 类作用域与继承
## 15.7 构造函数与拷贝控制
### 15.7.1 虚析构函数
### 15.7.2 合成拷贝控制和继承
### 15.7.3 子类拷贝控制成员
### 15.7.4 继承的构造函数
## 15.8 容器和继承
## 关键术语
