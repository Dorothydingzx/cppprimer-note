## 15.1 面向对象：介绍
## 15.2 定义基类和子类
### 15.2.1 定义基类
### 15.2.2 定义子类

**继承和静态成员**

如果在基类中定义了静态成员，那么整个继承层级中只有此成员的唯一定义。不管从一个基类中派生了多少类，每个静态成员只存在一份实例。如：
````cpp
class Base {
public:
    static void statmem();
};
class Derived : public Base {
    void f(const Derived &);
};
````
静态成员遵循常规的访问控制。如果一个成员在基类中是 private 的，那么派生类将无法访问它。如果成员是可访问的，则可以基类或派生类中使用此 static 成员。如：
````cpp
void Derived::f(const Derived &derived_obj)
{
    //可以通过基类访问
    Base::statmem();
    //可以通过派生类访问
    Derived::statmem();
    //可以通过派生对象访问基类中的静态成员
    derived_obj.statmem();
    //可以通过当前对象访问
    statmem();
}
````

**声明派生类**

派生类的声明与常规类的声明是一样的。声明中包含类的名字，但不包含派生列表。如：
````cpp
class Bulk_quote : public Quote; //错误：声明类中不能出现派生列表
class Bulk_quote; //正确的声明派生类的方式
````
声明的目的在于让程序知晓某个名字的存在以及它表示什么类型的实体，如：类、函数或变量。派生列表和所有其他的定义细节必须一起出现在类体中。

**被用作基类的类**

一个类在被用作基类之前必须定义而不能仅仅只声明。原因在于，每个派生类都包含并且可能使用其从基类继承来的成员。为了使用这些成员，派生类必须知道它们具体是什么。这也隐式说明一个类不能派生它本身。

一个类是基类，同时它是一个派生类。如：
````cpp
class Base {};
class D1 : public Base {};
//D1 既是基类也是派生类
class D2 : public D1 {};
````
在这个层级中，Base 是 D1 的直接基类（direct base），是 D2 的间接基类（indirect base）。直接基类被放在派生列表中，间接基类是派生类通过其直接基类继承来的。

每个类都继承其直接基类的所有成员。最具体的派生类将继承其直接基类的所有成员，直接基类中的成员包含它自己从它的基类中继承来的成员，以此类推到整个继承链的顶端。所以，最具体的派生对象将包含其直接基类的子对象以及每个间接基类的子对象。

### 15.2.3 转换和继承
## 15.3 虚函数
## 15.4 抽象基类
## 15.5 访问控制与继承
## 15.6 类作用域与继承
## 15.7 构造函数与拷贝控制
### 15.7.1 虚析构函数
### 15.7.2 合成拷贝控制和继承
### 15.7.3 子类拷贝控制成员
### 15.7.4 继承的构造函数
## 15.8 容器和继承
## 关键术语
