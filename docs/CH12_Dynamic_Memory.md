新版本的 C++ 最重要的更新之一就是提供了更为强大的智能指针（smart pointer），智能指针是模拟指针的抽象数据结构，提供了额外的功能包括内存管理（memory management）或者界限检查（bounds checking）。这些特性在保留性能的情况下，减少了因为指针滥用导致的难以查找的 bug。智能指针常用于跟踪其指向的内存，亦可用于管理其它资源，比如：网络连接和文件句柄。

智能指针能够自动回收内存，对象自动析构。但拥有对象的最后一个智能指针销毁时（本地变量离开其作用域），其会自动析构对象并回收内存。其中 shared_ptr 通过引用计数来实现，而 unique_ptr 则完全拥有其指向的对象。

有自动垃圾回收机制的语言不需要智能指针用于内存管理，但依然可以用于缓存管理和其它资源管理（如：文件句柄和网络）。

前面章节介绍的对象使用都没有动态内存。全局对象在程序启动时分配，并在程序结束时销毁。本地自动对象在指令流经过其定义位置时创建，在离开其创建块时销毁。本地静态对象则在第一次使用时创建，在程序结束时销毁。

动态分配对象（dynamically allocated object）的生命周期独立于其创建的位置，除非是显式销毁，否则将持续到程序结束。如何正确释放动态对象非常容易产生 bug。为了安全使用动态对象，C++ 提供了两种智能指针来管理动态分配对象。智能指针保证会在没有任何地方引用了此对象时，释放其内存。

之前的程序只使用了静态（static）和堆栈（stack）内存。静态内存用于本地静态变量、类静态成员和定义在任何函数之外的变量。堆栈则用于函数内定义的自动对象。在静态和堆栈内存中分配的对象，其创建和销毁都由编译器管理。除此之外，每个程序还有一个内存池，这种内存被称为自由内存（free store）或堆（heap）。程序使用堆来分配给动态对象，即在运行时分配内存给对象。这种对象的生命周期由程序进行管理，代码中必须显式销毁不再使用的对象。

除非是必要的情况下，不应该直接管理动态内存，因为，这是非常容易出错的。

## 12.1 动态内存和智能指针

在 C++ 中使用 new 操作来分配和初始化动态对象，并返回一个指向对象的指针。delete 操作符则以此指针为操作数，销毁其指向的对象，并释放其内存。

动态内存容易出错的原因在于：很难在正确的时机释放内存。我们可能忘记释放并造成内存泄漏（memory leak）或者在指针依然在使用时释放其内存，这种时候指针指向的内存是无效的。

为了使得动态内存易于使用并且更加安全，新标准中提供了两个智能指针来管理动态对象。`shared_ptr` 允许多个指针指向同一个对象，`unique_ptr` 则拥有其指向的对象，因而是排外的。标准库还定义了 `weak_ptr` 表示对 `shared_ptr` 管理的对象的弱引用。所有这三个类都定义在 `memory` 头文件中。

### 12.1.1 `shared_ptr` 类

指针指针是模板类，创建智能指针需要提供指向的对象类型作为模板参数。如：
````cpp
shared_ptr<string> p1;
shared_ptr<list<int>> p2;
````
默认初始化的智能指针表示空指针。

使用智能指针的方式于常规指针是一样的。解引用智能指针返回其指向的对象引用。当将智能指针用于条件语句中，效果相当于测试其是否是空指针。

以下是 `shared_ptr` 和 `unique_ptr` 共有的操作：

- `shared_ptr<T> sp` `unique_ptr<T> up` 指向 T 类型的对象的空指针；
- `p` 将 p 用于条件中，如果其指向一个对象将返回 true；
- `*p` 解引用 p 从而得到其指向的对象，如果没有 p 是空的，结果未定义；
- `p->mem` 等同于 `(*p).mem`；
- `p.get()` 返回 p 中保存的对象指针。使用时需要当心：返回的指针所指向的对象可能被智能指针删除；
- `swap(p, q)` `p.swap(q)` 交换 p 和 q 中的指针；

以下是 `shared_ptr` 特有的操作：

- `make_shared<T>(args)` 返回一个类型为 T 的动态对象的智能指针，使用 args 进行初始化对象；
- `shared_ptr<T>p(q)` p 是 `shared_ptr` q 的拷贝，将增加 q 的引用计数，q 中指针必须可以转为 `T*`；
- `p = q` p 和 q 是指向可转换指针的智能指针 `shared_ptr`。减少 p 的引用计数，并增加 q 的引用计数，当 p 的引用计数为 0 时，删除其所指向的动态对象的内存；
- `p.unique()` 当 p 的引用计数是 1 时，返回 true，否则返回 false；
- `p.use_count()` 返回 p 所指向对象的引用计数，可能是一个很慢的操作，主要用于调试目的；

**make_shared函数**

最安全的分配和使用动态内存的方式就是调用库函数 `make_shared`。这个函数分配并初始化动态对象，然后返回一个指向它的 `shared_ptr` 智能指针。`make_shared` 被定义在 memory 头文件中，它是一个模板函数，调用时需要提供需要创建的对象类型。如：
````cpp
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shared<string>(10, '9');
shared_ptr<int> p5 = make_shared<int>();  //此时 p5 指向的对象将被值初始化
auto p6 = make_shared<vector<string>>(); //分配一个空的 vector<string> 对象
````
`make_shared` 使用其参数构建一个给定类型的对象，创建类对象时传的参数必须匹配其任一构造函数的原型，创建内置类型对象则直接传递其值。如果没有传递任何参数，则对象是值初始化的。

**拷贝和赋值`shared_ptr`**

当拷贝或赋值 `shared_ptr` 时，会相应更新各自对动态对象的引用计数。当拷贝 `shared_ptr` 时，计数增加，例如：当用于初始化另一个 `shared_ptr` 或者在赋值表达式中处于等号右边，或传递给函数、从函数中返回都会增加其引用计数。而当给 `shared_ptr` 赋予新值时，或者 `shared_ptr` 对象本身被销毁时，引用计数就会减少。

一旦引用计数变为 0 之后，`shared_ptr` 就会自动释放其指向的对象的内存。
````cpp
auto r = make_shared<int>(42);
r = q;
````
赋值给 r，将增加 q 所指向的对象的引用，而减少 r 原本所指向对象的引用，最终结果将导致那个对象被销毁。

实现上是否使用计数器或者别的数据结构来跟踪到底有多少个计数器指向同一个对象。关键点在于 `shared_ptr` 类本身去跟踪有多少个智能指针指向同一个对象并且在合适的时机自动释放。

**`shared_ptr`自动释放其指向的对象...**

当最后一个指向对象的 `shared_ptr` 被销毁时，其指向的对象将自动销毁。销毁对象使用的成员函数是析构函数（destructor）。类似于构造函数，每个类都有析构函数。构造函数用于控制初始化，析构函数控制当对象销毁时发生什么。

`shared_ptr` 的析构函数递减其引用计数，当引用计数变为 0 时，`shared_ptr` 的析构函数将销毁其指向的对象，并释放其内存。

**并自动释放与其相关动态对象的内存**

`shared_ptr` 可以自动释放动态对象使得使用动态内存相当简单。
````cpp
shared_ptr<Foo> factory(T arg)
{
    return make_shared<Foo>(arg);
}
void use_factory(T arg)
{
    shared_ptr<Foo> p = factory(arg);
}
````
当 p 被销毁时，其引用计数将递减。由于 p 是指向 factory 分配的动态内存的唯一指针，当 p 被销毁时，它会自动销毁其指向的对象，并且内存将被释放。而如果有任何其它 `shared_ptr` 指向这个对象，那么它就不会被释放内存。

由于内存只有到了最后一个 `shared_ptr` 销毁后才会释放，所以重要的是确保当不再需要动态对象时，`shared_ptr` 对象不会一直存在。一种可能保存不必要的 `shared_ptr` 是在将其放在容器中，之后又调整了容器使得不再需要所有元素，应当将不需要的元素擦除。

**类与具有动态生命周期的资源**

程序在以下三种情况下会使用动态内存：

1. 不知道需要多少对象；
2. 不知道需要的对象的精确类型；
3. 在多个对象之间共享数据；

**定义 StrBlob 类**

代码见：[StrBlob.cc](https://github.com/chuenlungwang/cppprimer-note/blob/master/code/StrBlob.cc)

最好的实现新集合类型的方式是使用容器库来管理元素，这样可以让容器库来管理元素的内存。然而，在 StrBlob 中不能直接存储 vector ，原因在于 vector 需要在与 StrBlobPtr 共享。为了共享元素可以在其中一个销毁时依然存在，需要将 vector 放在动态内存中，并由 `shared_ptr` 进行管理。

值得注意的是 StrBlob 有一个以 `initializer_list<string>` 为参数的构造函数，这是新标准中给列初始化专门设计的。

### 12.1.2 直接管理内存
### 12.1.3 将 `shared_ptr` 运用于 new
### 12.1.4 智能指针和异常
### 12.1.5 `unique_ptr`
### 12.1.6 `weak_ptr`
## 12.2 动态数组
### 12.2.1 new 和数组
### 12.2.2 allocator 类
## 12.3 使用库：文本查询程序
### 12.3.1 设计
### 12.3.2 定义查询类
## 关键术语
