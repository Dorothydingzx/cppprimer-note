在第4章中，我们了解到 C++ 定义了大量操作符，并且为内置类型之间的转换定义了自动转换。这些使得程序员可以很方便的写出混合类型的表达式。

同时 C++ 允许我们定义当将操作符运用于类类型对象时的含义。它还允许我们定义类类行之间的转换。类类型转换的使用类似于内置类型转换在需要时将一个类型的对象隐式转为另外一个类型对象。

操作符重载（operator overloading）允许我们定义运用于类类型的操作符的含义。谨慎地使用操作符重载可以使得程序更加容易读和写。如果之前地 `Sales_item` 类定义了重载的输入、输出和加操作符，那么可以如下操作：
````cpp
cout << item1 + item2;
````
如果没有定义这些重载操作符的话，操作就会没有那么简洁：
````cpp
print(cout, add(data1, data2));
````

## 14.1 基本概念

重载操作符是具有特殊名字的函数：关键字 `operator` 后跟被定义的操作符的符号。与任何别的函数一样，重载操作符有返回值类型、参数列表和函数体。

重载的操作符函数具有与操作符的操作数一样的参数个数。一元操作符只有一个参数；二元操作符有两个参数。在二元操作符中，左边的操作数传递给第一个参数，右边的操作数传递给第二个参数。除了重载函数调用操作符（function-call operator）`operator()` 之外，重载的操作符没有默认的参数。

如果操作符函数是一个成员函数，第一个（左边）操作数将绑定到隐式的 this 指针。由于第一个操作数隐式绑定到 this，成员操作符函数的显式参数将比操作符的操作数少一个。

注意：当重载操作符是成员函数，this 将绑定到左手边的操作数。成员操作符函数将少一个显式的参数。

一个操作符函数必须要么是类的成员要么至少有一个参数是此类类型：
````cpp
//错误：不能重新定义内置类型的操作符
int operator+(int, int);
````
这个限制意味着我们不能改变内置类型的操作符的含义。

我们可以重载大部分但不是全部的操作符。下表将说明哪些是可以重载的，哪些是不能重载的操作符。`new` 和 `delete` 将在19.1.1节说明。

**可以重载的操作符**

`+`  `-`   `*`   `/`     `%`      `^`

`&`  `|`   `~`   `!`     `,`      `=`

`<`  `>`   `<=`  `>=`    `++`     `--`

`<<` `>>`  `==`  `!=`    `&&`     `||`

`+=` `-=`  `/=`  `%=`    `^=`     `&=`

`|=` `*=`  `<<=` `>>=`   `[]`     `()`

`->` `->*` `new` `new[]` `delete` `delete[]`

**不能重载的操作符**

`::` `.*` `.` `?:`

我们只能重载已经存在的操作符，而不能发明新的操作符符号（symbol）。对于符号如（`+` `-` `*` 和 `&`）同时可以作为一元和二元操作符的。两者之一或者两种性的操作符都可以被重载。参数的个数决定哪个操作符被重载。

重载的操作符与内置类型的操作符具有相同的优先级（precedence）和结合性（associativity）。而不管操作数的类型。

**直接调用重载操作符函数**

通常我们通过使用操作符于合适类型的参数上间接调用重载的操作符函数。然而，我们可以通过调用常规函数的方式直接调用重载操作符函数。我们直接输入函数的名字（operator `op`）并传递合适类型的合适数目的参数：
````cpp
data1 + data2; //常规的表达式
operator+(data1+data2); //相同的函数调用方式
````

这些调用是相同的：两者都调用非成员函数 `operator+`，并传递 data1 作为第一个参数以及 data2 作为第二个参数。

我们调用一个成员操作函数与调用任何别的成员函数的方式是一样的。我们指定对象（或指针）的名字，然后使用点号（或箭头）操作符来获取想要调用的函数：
````cpp
data1 += data2; //表达式方式的调用
data1.operator+=(data2); //相同的成员函数调用方式
````
上面两个语句都调用成员函数 `operator+=`，将 `this` 绑定到 data1 的地址上，将 data2 作为参数传递。

**有些操作符不应该被重载**

回想一个有些操作符保证操作数的求值顺序是固定的。由于重载操作符就是函数调用，这些保证就不能运用于重载的操作符。尤其是，逻辑与（&&）和逻辑或（||）以及逗号操作符的操作数求值顺序就不会保留。特别是，重载版本的 `&&` 和 `||` 操作符不能保留内置操作符的短路求值（short-circuit evaluation）特性。两个操作数将总是被求值。

由于这些操作符的重载版本不会保留求值顺序和/或短路求值，重载它们并不是一个好主意。如果用户习惯的方式被改变了是令人惊讶的。

不要重载逗号操作符的另外一个原因是（同样使用于取地址 `&` 操作符）是语言定义了当逗号和取地址操作符用于类类型对象时的含义。由于这些操作符有内置的含义，它们通常不应该被重载。

**最佳实践**：通常，逗号、取地址和逻辑与以及逻辑或操作符不应该被重载。

**使用与内置操作符含义一致的定义**

当我们设计类时，我们应该总是第一想到这个类应该提供什么操作。只有当你了解需要哪些操作时，你才能决定是将这个操作定义为常规函数或者是重载的操作符。那些在逻辑上匹配操作符的操作是定义重载操作符的好的候选对象：

- 如果类有 IO 操作，将移位操作符定义地与内置类型的 IO 含义一致；
- 如果类有一个操作可以比较相等性，定义 `operator==`，如果类有 `operator=`，通常需要定义 `operator!=`；
- 如果一个类具有单一的自然顺序（natural ordering）操作，定义 `operator<`，如果类有 `operator<`，它通常需要所有的关系操作符；
- 重载操作符的返回值类型通常需要与内置版本的操作符的返回值类型：逻辑和关系操作符应该返回 bool 值，算术操作符应该返回本类类型的值，赋值和复合赋值操作符应该返回左手操作数的引用；

**赋值和复合赋值操作符**

赋值操作符应该表现地类似于编译器合成的操作符：在赋值之后，左边和右边的操作数应该具有相同的值，并且操作符应该返回左边操作数的引用。重载的赋值操作符应该是内置类型的赋值操作的泛化（generalize）而不是绕过它。

**注意：谨慎使用操作符重载**

每个操作符在用于内置类型时都有一个固定含义。比如：二元 `+` 的含义就是表示加法。将二元 `+` 映射到类类型的类似操作上将提供方便的简化符号。如，标准库 string 类型遵从许多编程语言中共通的约定，用 `+` 表示拼接，将一个 string 添加到另外一个。

操作符重载在内置操作符能够在逻辑上映射到我们的类型上的操作时时最有用的。使用重载的操作符而不是命名的操作将使得我们程序更加自然和直观。滥用操作符重载则使得类难以理解。

明显的滥用操作符重载在现实中是十分少见的。更加常见的是扭曲一个操作符的“正常”含义来强制适用于一个给定的类型。只有在操作对于用户来说是明确（unambiguous）的时候才应该使用操作符。如果一个操作符看起来好像有多于一个解释，那么这个操作符就是模糊的。

如果一个类具有算术（arithmetic）或者按位（bitwise）操作符，那么同时提供对应的复合赋值操作符是一个好的想法。当然这些重载的操作符应该在行为上与内置操作符的含义一致。

**选择作为成员或者非成员实现**

当我们定义重载操作符时，我们必须决定使得操作符作为一个类成员还是一个普通的非成员函数。在某些情况下，这是没得选的，一些操作符必须是成员；在另外一些情况，我们又不能让它成为成员函数。

下面的指导方针可以帮助我们决定是否让一个操作符成为成员或者一个普通的非成员函数：

- 赋值（`=`）、下标（`[]`）、调用（`()`）和成员访问箭头（`->`）必须被定义为成员函数；
- 复合赋值操作符通常应该（ought）是成员，然而，不像赋值操作符，这不是必须的；
- 改变对象状态的操作符或者与这个类类型关系十分密切（closely tied）的操作符应该（should）被定义为成员，如：自增、自减和解引用操作符；
- 对称操作符——它们可以转换任何一个操作数，比如算术运算、相等性比较、关系比较和按位操作符——通常应该（should）被定义为常规的非成员函数；

程序员会期望将对称操作符用于混合类型（mixed types）的表达式中。比如我们可以将 int 和 double 类型值进行相加。加法是对称的，因为我们可以让左边或者右边操作数的类型作为重载操作符的类型。如果我们想要提供类似的混合类型表达式于类对象上，那么操作符就必须被定义为非成员函数。

当我们将一个操作符定义为成员函数时，左边操作数将必须是操作符作为成员的类的对象。如：
````cpp
string s = "world";
string t = s + "!";
string u = "hi" + s; //如果 + 是 string 的成员，此句将是错误
````
如果 `operator+` 是 string 类的一个成员，那么第一个加法将等价于 `s.operator+("!")`，同样，`"hi" + s` 将等价于 `"hi".operator+(s)`，然而类型 `"hi"` 是 `const char*`，那个类型是内置类型；它根本没有成员函数。

由于 string 将 `+` 定义为普通的非成员函数，`"hi" + s` 等价于 `operator+("hi", s)`，与任何函数调用一样，其中任意一个实参都可以转为合适的形参类型。它唯一的要求就是至少有一个操作数是 string 类型，且两个操作数都可以明确地转换为 string。

## 14.2 输入输出操作符

正如我们所见，IO 标准库使用 `>>` 和 `<<` 来表达输入和输出。IO 标准库自身定义如何读写内置类型的这些操作符的版本。如果类需要支持 IO ，那么同样需要定义自己的这些操作符的版本。

### 14.2.1 重载输出操作符 `<<`

通常输出操作符的第一个形参是一个非 const ostream 对象的引用。第二个参数应该是一个我们想要打印的类类型的 const 对象引用。为了以其它的输出操作符一致，`operator<<` 通常应该返回其 ostream 参数。如：
````cpp
ostream & operator<<(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
       << item.revenue << " " << item.avg_price();
    return os;
}
````

**输出操作符通常只做最少的格式化**

内置类型的输出操作符只做最少的格式化，特别是不打印任何换行符。用户对于类输出操作符也期待类似的行为。输出操作符只做最少的格式化将让用户控制输出的细节。

**IO操作符必须是非成员函数**

符合 iostream 标准库中的约定的输入输出操作符应该被定义为常规的非成员函数。这些操作符不能我们自己的类的成员。如果是的话，那么左边的操作数将不得不是我们自己的类类型对象：`data << cout;`

如果他们必须是哪个类的成员的话，他们最好是 istream 或者 ostream 的成员。然而，这些对象是标准库的一部分，我们是不能添加成员到这些类的。

因而，如果我们想要为我们的类型定义 IO 操作符的话，我们必须将其定义为非成员函数。当然，IO 操作符通常需要读或写非 public 数据成员。因而，IO 操作符通常被声明为友元。

### 14.2.2 重载输入操作符 `>>`

通常输入操作符的第一个参数是输入流对象的引用，第二个参数是写入的对象的非 const 引用。操作符通常返回给定流对象的引用。第二个参数必须是非 const 的，是由于输入操作符的目的就在于将输入写入到此对象中。如：
````cpp
istream &operator>>(istream &is, Sales_data &item)
{
    double price;
    is >> item.bookNo >> item.units_sold >> price;
    if (is)
      item.revenue = item.units_sold * price;
    else
      item = Sales_data();
    return is;
}
````
`if` 检查读取是否成功，如果发生了 IO 错误，操作符将给定的对象重置为空的 `Sales_data` 对象。这样将保证对象处于一致的状态。（Effective C++ 要求的基本异常安全就是让对象不论任何时候都处于一致的状态，而“强烈保证”则是不论发生任何异常，对象处于不变的状态）。

注意：输入操作符必须处理可能出现的输入错误；输出操作符通常没有这样的烦恼；

**在输入时发生的错误**

**指示发生的错误**

## 14.3 算术和关系操作符

### 14.3.1 相等操作符

### 14.3.2 关系操作符

## 14.4 赋值操作符

**复合赋值操作符**

## 14.5 下标操作符

## 14.6 自增和自减操作符

**定义前置自增/自减操作符**

**区别前置和后置操作符**

**显式调用后置操作符**

## 14.7 成员访问操作符

**箭头操作符的返回值的限制**

## 14.8 函数调用操作符

**具有状态的函数对象类（Function-Object Classes with State）**

### 14.8.1 Lambdas 是函数对象

**表示具有捕获值的 lambda 的类**

### 14.8.2 标准库中的函数对象

**使用标准库函数对象于通用算法**

### 14.8.3 可调用对象和 std::function

**不同的类型可以有相同的调用签名**

**标准库函数类型**

**重载的 Functions 和函数**

## 14.9 重载、转换和操作符

### 14.9.1 转换操作符

**定义一个具有转换操作符的类**

**注意：避免滥用转换函数**

**转换操作符可能会产生令人惊讶的结果**

**显式转换操作符**

**转换为 bool 值**

### 14.9.2 避免二义性转换

**参数匹配和相互转换**

**二义性和多重转换到内置类型**

**重载函数和转换构造函数**

**注意：转换和操作符**

**重载函数和用户定义的转换**

### 14.9.3 函数匹配和重载操作符

## 关键术语