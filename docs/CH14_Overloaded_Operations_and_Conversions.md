在第4章中，我们了解到 C++ 定义了大量操作符，并且为内置类型之间的转换定义了自动转换。这些使得程序员可以很方便的写出混合类型的表达式。

同时 C++ 允许我们定义当将操作符运用于类类型对象时的含义。它还允许我们定义类类行之间的转换。类类型转换的使用类似于内置类型转换在需要时将一个类型的对象隐式转为另外一个类型对象。

操作符重载（operator overloading）允许我们定义运用于类类型的操作符的含义。谨慎地使用操作符重载可以使得程序更加容易读和写。如果之前地 `Sales_item` 类定义了重载的输入、输出和加操作符，那么可以如下操作：
````cpp
cout << item1 + item2;
````
如果没有定义这些重载操作符的话，操作就会没有那么简洁：
````cpp
print(cout, add(data1, data2));
````

## 14.1 基本概念

重载操作符是具有特殊名字的函数：关键字 `operator` 后跟被定义的操作符的符号。与任何别的函数一样，重载操作符有返回值类型、参数列表和函数体。

重载的操作符函数具有与操作符的操作数一样的参数个数。一元操作符只有一个参数；二元操作符有两个参数。在二元操作符中，左边的操作数传递给第一个参数，右边的操作数传递给第二个参数。除了重载函数调用操作符（function-call operator）`operator()` 之外，重载的操作符没有默认的参数。

如果操作符函数是一个成员函数，第一个（左边）操作数将绑定到隐式的 this 指针。由于第一个操作数隐式绑定到 this，成员操作符函数的显式参数将比操作符的操作数少一个。

注意：当重载操作符是成员函数，this 将绑定到左手边的操作数。成员操作符函数将少一个显式的参数。

一个操作符函数必须要么是类的成员要么至少有一个参数是此类类型：
````cpp
//错误：不能重新定义内置类型的操作符
int operator+(int, int);
````
这个限制意味着我们不能改变内置类型的操作符的含义。

我们可以重载大部分但不是全部的操作符。下表将说明哪些是可以重载的，哪些是不能重载的操作符。`new` 和 `delete` 将在19.1.1节说明。

**可以重载的操作符**

`+`  `-`   `*`   `/`     `%`      `^`

`&`  `|`   `~`   `!`     `,`      `=`

`<`  `>`   `<=`  `>=`    `++`     `--`

`<<` `>>`  `==`  `!=`    `&&`     `||`

`+=` `-=`  `/=`  `%=`    `^=`     `&=`

`|=` `*=`  `<<=` `>>=`   `[]`     `()`

`->` `->*` `new` `new[]` `delete` `delete[]`

**不能重载的操作符**

`::` `.*` `.` `?:`

我们只能重载已经存在的操作符，而不能发明新的操作符符号（symbol）。对于符号如（`+` `-` `*` 和 `&`）同时可以作为一元和二元操作符的。两者之一或者两种性的操作符都可以被重载。参数的个数决定哪个操作符被重载。

重载的操作符与内置类型的操作符具有相同的优先级（precedence）和结合性（associativity）。而不管操作数的类型。

**直接调用重载操作符函数**

通常我们通过使用操作符于合适类型的参数上间接调用重载的操作符函数。然而，我们可以通过调用常规函数的方式直接调用重载操作符函数。我们直接输入函数的名字（operator `op`）并传递合适类型的合适数目的参数：
````cpp
data1 + data2; //常规的表达式
operator+(data1+data2); //相同的函数调用方式
````

这些调用是相同的：两者都调用非成员函数 `operator+`，并传递 data1 作为第一个参数以及 data2 作为第二个参数。

我们调用一个成员操作函数与调用任何别的成员函数的方式是一样的。我们指定对象（或指针）的名字，然后使用点号（或箭头）操作符来获取想要调用的函数：
````cpp
data1 += data2; //表达式方式的调用
data1.operator+=(data2); //相同的成员函数调用方式
````
上面两个语句都调用成员函数 `operator+=`，将 `this` 绑定到 data1 的地址上，将 data2 作为参数传递。

**有些操作符不应该被重载**

回想一个有些操作符保证操作数的求值顺序是固定的。由于重载操作符就是函数调用，这些保证就不能运用于重载的操作符。尤其是，逻辑与（&&）和逻辑或（||）以及逗号操作符的操作数求值顺序就不会保留。特别是，重载版本的 `&&` 和 `||` 操作符不能保留内置操作符的短路求值（short-circuit evaluation）特性。两个操作数将总是被求值。

由于这些操作符的重载版本不会保留求值顺序和/或短路求值，重载它们并不是一个好主意。如果用户习惯的方式被改变了是令人惊讶的。

不要重载逗号操作符的另外一个原因是（同样使用于取地址 `&` 操作符）是语言定义了当逗号和取地址操作符用于类类型对象时的含义。由于这些操作符有内置的含义，它们通常不应该被重载。

**最佳实践** ：通常，逗号、取地址和逻辑与以及逻辑或操作符不应该被重载。

**使用与内置操作符含义一致的定义**

当我们设计类时，我们应该总是第一想到这个类应该提供什么操作。只有当你了解需要哪些操作时，你才能决定是将这个操作定义为常规函数或者是重载的操作符。那些在逻辑上匹配操作符的操作是定义重载操作符的好的候选对象：

- 如果类有 IO 操作，将移位操作符定义地与内置类型的 IO 含义一致；
- 如果类有一个操作可以比较相等性，定义 `operator==`，如果类有 `operator=`，通常需要定义 `operator!=`；
- 如果一个类具有单一的自然顺序（natural ordering）操作，定义 `operator<`，如果类有 `operator<`，它通常需要所有的关系操作符；
- 重载操作符的返回值类型通常需要与内置版本的操作符的返回值类型：逻辑和关系操作符应该返回 bool 值，算术操作符应该返回本类类型的值，赋值和复合赋值操作符应该返回左手操作数的引用；

**赋值和复合赋值操作符**

赋值操作符应该表现地类似于编译器合成的操作符：在赋值之后，左边和右边的操作数应该具有相同的值，并且操作符应该返回左边操作数的引用。重载的赋值操作符应该是内置类型的赋值操作的泛化（generalize）而不是绕过它。

**注意：谨慎使用操作符重载**

每个操作符在用于内置类型时都有一个固定含义。比如：二元 `+` 的含义就是表示加法。将二元 `+` 映射到类类型的类似操作上将提供方便的简化符号。如，标准库 string 类型遵从许多编程语言中共通的约定，用 `+` 表示拼接，将一个 string 添加到另外一个。

操作符重载在内置操作符能够在逻辑上映射到我们的类型上的操作时时最有用的。使用重载的操作符而不是命名的操作将使得我们程序更加自然和直观。滥用操作符重载则使得类难以理解。

明显的滥用操作符重载在现实中是十分少见的。更加常见的是扭曲一个操作符的“正常”含义来强制适用于一个给定的类型。只有在操作对于用户来说是明确（unambiguous）的时候才应该使用操作符。如果一个操作符看起来好像有多于一个解释，那么这个操作符就是模糊的。

如果一个类具有算术（arithmetic）或者按位（bitwise）操作符，那么同时提供对应的复合赋值操作符是一个好的想法。当然这些重载的操作符应该在行为上与内置操作符的含义一致。

**选择作为成员或者非成员实现**

当我们定义重载操作符时，我们必须决定使得操作符作为一个类成员还是一个普通的非成员函数。在某些情况下，这是没得选的，一些操作符必须是成员；在另外一些情况，我们又不能让它成为成员函数。

下面的指导方针可以帮助我们决定是否让一个操作符成为成员或者一个普通的非成员函数：

- 赋值（`=`）、下标（`[]`）、调用（`()`）和成员访问箭头（`->`）必须被定义为成员函数；
- 复合赋值操作符通常应该（ought）是成员，然而，不像赋值操作符，这不是必须的；
- 改变对象状态的操作符或者与这个类类型关系十分密切（closely tied）的操作符应该（should）被定义为成员，如：自增、自减和解引用操作符；
- 对称操作符——它们可以转换任何一个操作数，比如算术运算、相等性比较、关系比较和按位操作符——通常应该（should）被定义为常规的非成员函数；

程序员会期望将对称操作符用于混合类型（mixed types）的表达式中。比如我们可以将 int 和 double 类型值进行相加。加法是对称的，因为我们可以让左边或者右边操作数的类型作为重载操作符的类型。如果我们想要提供类似的混合类型表达式于类对象上，那么操作符就必须被定义为非成员函数。

当我们将一个操作符定义为成员函数时，左边操作数将必须是操作符作为成员的类的对象。如：
````cpp
string s = "world";
string t = s + "!";
string u = "hi" + s; //如果 + 是 string 的成员，此句将是错误
````
如果 `operator+` 是 string 类的一个成员，那么第一个加法将等价于 `s.operator+("!")`，同样，`"hi" + s` 将等价于 `"hi".operator+(s)`，然而类型 `"hi"` 是 `const char*`，那个类型是内置类型；它根本没有成员函数。

由于 string 将 `+` 定义为普通的非成员函数，`"hi" + s` 等价于 `operator+("hi", s)`，与任何函数调用一样，其中任意一个实参都可以转为合适的形参类型。它唯一的要求就是至少有一个操作数是 string 类型，且两个操作数都可以明确地转换为 string。

## 14.2 输入输出操作符

正如我们所见，IO 标准库使用 `>>` 和 `<<` 来表达输入和输出。IO 标准库自身定义如何读写内置类型的这些操作符的版本。如果类需要支持 IO ，那么同样需要定义自己的这些操作符的版本。

### 14.2.1 重载输出操作符 `<<`

通常输出操作符的第一个形参是一个非 const ostream 对象的引用。第二个参数应该是一个我们想要打印的类类型的 const 对象引用。为了以其它的输出操作符一致，`operator<<` 通常应该返回其 ostream 参数。如：
````cpp
ostream & operator<<(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
       << item.revenue << " " << item.avg_price();
    return os;
}
````

**输出操作符通常只做最少的格式化**

内置类型的输出操作符只做最少的格式化，特别是不打印任何换行符。用户对于类输出操作符也期待类似的行为。输出操作符只做最少的格式化将让用户控制输出的细节。

**IO操作符必须是非成员函数**

符合 iostream 标准库中的约定的输入输出操作符应该被定义为常规的非成员函数。这些操作符不能我们自己的类的成员。如果是的话，那么左边的操作数将不得不是我们自己的类类型对象：`data << cout;`

如果他们必须是哪个类的成员的话，他们最好是 istream 或者 ostream 的成员。然而，这些对象是标准库的一部分，我们是不能添加成员到这些类的。

因而，如果我们想要为我们的类型定义 IO 操作符的话，我们必须将其定义为非成员函数。当然，IO 操作符通常需要读或写非 public 数据成员。因而，IO 操作符通常被声明为友元。

### 14.2.2 重载输入操作符 `>>`

通常输入操作符的第一个参数是输入流对象的引用，第二个参数是写入的对象的非 const 引用。操作符通常返回给定流对象的引用。第二个参数必须是非 const 的，是由于输入操作符的目的就在于将输入写入到此对象中。如：
````cpp
istream &operator>>(istream &is, Sales_data &item)
{
    double price;
    is >> item.bookNo >> item.units_sold >> price;
    if (is)
      item.revenue = item.units_sold * price;
    else
      item = Sales_data();
    return is;
}
````
`if` 检查读取是否成功，如果发生了 IO 错误，操作符将给定的对象重置为空的 `Sales_data` 对象。这样将保证对象处于一致的状态。（Effective C++ 要求的基本异常安全就是让对象不论任何时候都处于一致的状态，而“强烈保证”则是不论发生任何异常，对象处于不变的状态）。

注意：输入操作符必须处理可能出现的输入错误；输出操作符通常没有这样的烦恼；

**在输入时发生的错误**

在输入操作符中可能发生如下种类的错误：

- 读操作可能会应为流包含了不正确的类型的数据。比如，如果想要读取两个数字类型的数据，但是输入流中包含的不是数字类型的，那么读取和接下来的使用将会失败；
- 任何读操作都可能会遇到到达文件尾部（end-of-file）或者一些别的错误；

相较于每次读都进行检查，我们在读取所有数据之后并在使用这些数据之前进行一次检查。将对象置于有效的状态是非常重要的，因为对象可能会在错误发生前被部分地改变。

将对象置于一种有效的状态，将保护那些忽略了输入错误可能性的用户。对象将依然处于可用的状态，类似的，对象不会导致误导的结果，这是因为数据是内在一致的。

**最佳实践：**输入操作符应该决定在错误发生时采取生么措施进行错误恢复。

**指示发生的错误**

一些输入操作符需要做一些额外的数据校验。如需要对数据的合法范围进行校验，或者数据是合法的格式。在这种情况下输入操作符需要设置流的条件状态（condition state）来表示错误，即便从技术上来说实际上 IO 是成功的。通常输入操作符只能设置 `failbit`。设置 `eofbit` 将暗含文件被耗尽，设置 `badbit` 将表示流损坏。这些错误最好是留给 IO 库自己去设置。

## 14.3 算术和关系操作符

通常，我们讲算术和关系运算符定义为非成员函数，这样可以让左边或者右边的操作数可以进行合适的转换。这些操作符不应该改变操作数的状态，所以参数通常是 const 引用类型。

一个算术操作符通常会产生一个新的值，这个值是计算两个操作数所得到的。这个值区别于任何一个参数，并且是在本地变量中计算的。这个操作返回这个本地变量的拷贝作为结果。定义算术操作符的类通常会定义对应的复合赋值操作符。当一个类同时具有这两个操作符时，通常讲算术操作符定义为使用复合赋值操作符时更加高效的，如：
````cpp
Sales_data
operator+(const Sales_data &lhs, const Sales_data &rhs)
{
  Sales_data sum = lhs;
  sum += rhs;
  return sum;
}
````
提示：同时定义了算术运算符和相应的复合赋值操作符的类应该将算术运算符实现为复合赋值操作。

### 14.3.1 相等操作符

通常，C++ 的类定义相等操作符来测试两个对象是否相等。它们通常会比较每一个数据成员，只有在对应的所有成员都相等时才会认为是相等。如：
````cpp
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
  return lhs.isbn() == rhs.isbn() &&
         lhs.units_sold == rhs.units_sold &&
         lhs.revenue == rhs.revenue;
}
bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
{
  return !(lhs == rhs);
}
````
这些函数的定义是十分简单的，更为重要的它们所涉及到的设计原则：

- 如果一个类有操作来决定两个对象是否相等，它应该将函数定义为 `operator==` 而不是具名函数；用户会期待使用 `==` 来进行对象的比较；提供 `==` 意味着它们不需要学习和记住操作的新的名字；并且如果类定义了 `==` 操作符将更加容易使用标准库容器和算法；
- 如果一个类定义了 `operator==`，那么这个操作符通常应该决定给定对象是否具有相等的数据；
- 通常，相等操作符应该是可传递的，意味着如果 `a == b` 并且 `b ==c`，那么 `a == c` 应该同样为真；
- 如果一个类定义了 `operator==`，那么它通常应该定义 `operator!=`，两者是相互依存的；
- 相等或不等操作符应该将其工作交给另外一个去完成。意味着，其中一个操作符将做真正的比较对象的操作，而另外一个应该调用这个来完成其工作；

**最佳实践：**如果一个类具有逻辑上的相等比较操作通常应该定义 `operator=`，类定义 `==` 将使得其容易与通用算法一起使用。

### 14.3.2 关系操作符

定义相等操作符的类同样也会定义关系操作符。特别是由于关联容器和一些算法使用小于操作符，那么定义 `operator<` 将十分有用。

通常关系运算符应该：

1. 定义与作为关联容器中的键的要求一致的顺序关系；并且
2. 如果类同时定义了 `=`，那么应该定义与 `==` 一致的顺序关系。特别是，如果两个对象有 `!=` 的性质，那么一个对象应该 `<` 另外一个。

对于像 `Sales_data` 这种没有逻辑上的 `<` 概念的类型，最好是不要定义关系操作符。

**最佳实践：**如果存在 `<` 操作的单一逻辑上的定义，那么通常我们应该定义 `<` 操作符。然而，如果类同时有 `==`，只有在 `<` 和 `==` 操作符产生一致的结果时才重载 `<` 操作符。

## 14.4 赋值操作符

除了可以将相同类型的对象拷贝赋值或移动赋值给另外一个对象之外，一个类还可以定义额外的赋值操作符用于将其它类型的对象作为右边的操作数。

比如，vector 类定义了第三个赋值操作符，其参数是括号包围的元素（a braced list of elements），我们可以按如下方式使用操作符：
````cpp
vector<string> v;
v = {"a", "an", "the"};
````
我们可以将这个操作符添加到我们自己的 StrVec 类中：
````cpp
class StrVec {
public:
  StrVec &operator=(std::initializer_list<std::string>);
};
````
为了与内置类型的赋值操作（并且与已经定义的拷贝赋值和移动赋值操作符一致），我们的新的赋值操作符将返回左操作数的引用。
````cpp
StrVec &StrVec::operator=(std::initializer_list<string> il)
{
  auto data = alloc_n_copy(il.begin(), il.end());
  free();
  elements = data.first;
  first_free = cap = data.second;
  return *this;
}
````
与拷贝赋值和移动赋值操作符一样，其它重载的赋值操作符应该释放掉已经存在有元素并且创建新的元素。不同于拷贝赋值和移动赋值操作符，这个操作符不需要检查自赋值（self-assignment）。参数的类型是 `initializer_list<string>` 意味着 il 不可能与 this 所表示的对象相同。

提示：赋值操作符可以被多次重载。赋值操作符不管参数类型是什么都必须定义为成员函数。

**复合赋值操作符**

复合赋值操作符并不需要必须是成员。然而，我们倾向于将所有的赋值操作包括复合赋值操作定义在类中。为了与内置复合赋值操作符保持一致，这些操作符将返回左操作数的引用。比如：
````cpp
Sales_data &Sales_data::operator+=(const Sales_data &rhs)
{
  units_sold += rhs.units_sold;
  revenue += rhs.revenue;
  return *this;
}
````
**最佳实践：**赋值操作符必须是成员，复合赋值操作符应该是成员。这些操作符应该返回左边操作数的引用。

## 14.5 下标操作符

表示容器的类型通常会定义下标操作符 `operator[]` 来通过位置获取元素。重载下标操作符必须是成员函数。

为了兼容常规的下标操作符的含义，重载下表操作符通常返回获取的元素的引用。通过返回引用，下标操作可以用于赋值操作的任何一边。因而，同时定义 const 和非 const 版本的操作符是一个好的主意。当运用于 const 对象时，下标操作应该应该返回一个 const 引用，那么就不能对返回的对象进行赋值。

**最佳实践：**当一个类有下标操作符时，它通常应该定义两个版本：一个返回非 const 引用，另一个是 const 成员并返回 const 引用。如：
````cpp
class StrVec {
public:
  std::string &operator[](std::size_t n) { return elements[n]; }
  const std::string &operator[](std::size_t n) const
  { return elements[n]; }
private:
  std::string *elements;
};
````
我们可以按照类似于对 vector 或数组进行下标操作的方式使用这些曹祖福。由于重载下标操作符返回的是一个元素的引用，如果 StrVec 是非 const 的，我们就可以对元素进行赋值；如果对 const 对象进行下标操作，我们便不能这样做：

## 14.6 自增和自减操作符

自增（`++`）和自减（`--`）操作符最常被迭代器类实现。这个操作符让类在序列上的元素之间移动。语言并不要求这些操作符必须是类的成员。然而，由于这些操作符改变了它们操作的对象的状态，我们倾向于让它们成为成员。

对于内置类型，同时存在前置和后置版本的自增和自减操作符。我们同样也能同时为类类型定义前置和后置的版本。

**最佳实践：**定义自增和自减操作符的类应该同时定义前置和后置版本。这些操作符通常应该被定义为成员。

**定义前置自增/自减操作符**

为了演示，我们给 StrBlobPtr 类定义前置的自增和自减操作符：
````cpp
class StrBlobPtr {
public:
  StrBlobPtr &operator++();
  StrBlobPtr &operator--();
};
````
**最佳实践：**为了与内置类型操作符保持一致，前置操作符应该返回自增后或者自减后的对象的引用。

**区别前置和后置操作符**

当同时定义前置和后置版本时会遇到一个问题：正常的重载不能区分这两个操作符。前置和后置版本使用相同的符号，意味着重载版本具有相同的名字。它们同时具有相同的数目和类型的操作数。

为了解决这个问题，后置版本有一个额外的（不使用的）int 类型参数。当我们使用后置版本的操作符时，编译器给这个形参提供 0 作为实参。尽管后置版本的函数可以使用这个额外的参数，通常是不应该使用。这个参数本身就是后置操作符正常工作所不需要的。它存在的唯一目的就是让前置版本与后置版本进行区分。如：
````cpp
class StrBlobPtr {
public:
  StrBlobPtr operator++(int);
  StrBlobPtr operator--(int);
};
````
**最佳实践：**为了与内置类型操作符保持一致，后置操作符应该返回旧的（未自增或者未自减）的值。这个值将作为值返回而不是引用。

**注意：**int 参数没有被使用，所以我们没有给其一个名字。

**显式调用后置操作符**

我们可以显式调用重载的操作符作为另外一种在表达式中使用操作符的方式。如果我们想要用函数调用方式调用后置版本，我们就必须自己提供这个整数参数：
````cpp
StrBlobPtr p(a1);
p.operator++(0); //调用后置版本的 operator++
p.operator++(); //调用前置版本的 operator++
````
传递过去的值通常是被忽略的，但是依然需要传递这是为了告知编译器使用的是后置版本。

## 14.7 成员访问操作符

解引用（*）和箭头（`->`）操作符通常用于表示迭代器的类中，以及智能指针类。
````cpp
class StrBlobPtr {
public:
  std::string &operator*() const
  { return (*p)[curr]; }
  std::string *operator->() const
  { return & this->operator*(); }
};
````
箭头操作符通过调用解引用操作符并返回那个操作符的返回元素的地址来避免做任何实际的工作。

**注意：**箭头操作符必须是成员。解引用操作符就没有要求必须是成员，但通常应该被定义为成员。

这里值得注意的是我们将这些操作符定义为 const 成员。不像自增和自减操作符，获取成员不会改变 StrBlobPtr 自身的状态。同样需要注意的是这些操作符返回一个非 const string 对象的引用或指针。它们这样做的原因在于我们知道 StrBlobPtr 只能绑定到非 const StrBlob 对象上。以下是使用过程：
````cpp
StrBlob a1 = { "hi", "bye", "now" };
StrBlobPtr p(a1);
*p = "okay";
cout << p->size() << endl;
cout << (*p).size() << endl;
````

**箭头操作符的返回值的限制**

与绝大多数其它操作符一样，我们可以定义 `operator*` 做任何我们喜欢的操作，如返回固定值 42 或者打印对象的内容。当箭头操作符的重载不能这么做，箭头操作符不能丢失其成员访问的基本含义。我们不能改变箭头操作符获取成员的事实。

当我们书写 `point->mem` 时，point 必须要么是类类型对象的指针要么是一个重载了 `operator->` 的类对象。根据 point 的类型，书写 `point->mem` 等价于：
````cpp
(*point).mem; // point 是内置指针类型
point.operator->()->mem; // point 是类类型对象
````
除此之外的任何含义都是错误。意味着 `point->mem` 执行以下逻辑：

1. 如果 `point` 是指针，那么内置箭头操作符将被运用，意味着这个表达式等价于 `(*point).mem`，指针被解引用并且指定的成员从结果对象中取出。如果 point 指向的类型没有名字为 mem 的成员，那么代码将发生错误；
2. 如果 point 是一个定义了 `operator->` 的类对象，那么 `point.operator->()` 的结果将被用于获取 mem。如果结果是一个指针，那么从在这个指针上执行步骤1。如果结果是一个自身重载了 `operator->()` 对象，那么步骤2将在那个对象上重复。这个过程一直持续到要么得到一个对象（这个对象有指定的成员）的指针，要么返回一个其它的值，这第二种情况下代码是错误的。

**注意：**重载的箭头操作符必须要么返回一个类类型的指针要么是一个定义了自己的箭头操作符的类类型对象。

## 14.8 函数调用操作符

重载了调用操作符的类允许这个类型的对象就好像是函数一样使用。由于此类还存储了状态，它们将比常规函数更加的灵活。

作为一个简单的例子，下面的 absInt 就有一个调用操作符返回其参数的绝对值：
````cpp
struct absInt {
  int operator()(int val) const {
    return val < 0 ? -val : val;
  }
};
````
这个类定义了单一操作：函数调用操作符。这个操作符以 int 类型作为实参，并返回实参的绝对值。我们通过类似函数调用的方式将参数列表运用于 absInt 对象来调用这个 `()` 操作符。如
````cpp
int i = -42;
absInt absObj;
int ui = absObj(i); //将 i 传递给 absObj.operator()
````
尽管 absObj 是一个对象不是函数，我们可以“调用”这个对象。调用一个对象将运行其重载的调用操作符。在这种情况下，这个操作符取一个 int 值，并返回其绝对值。

**注意：**函数调用操作符必须是成员函数。一个类型可以定义多个调用操作符版本，其中每一个必须在参数的个数或类型不一样。

定义了调用操作符的类对象被称为函数对象（function objects），这种对象“在行为上类似于函数”，因为我们可以调用它们。

**具有状态的函数对象类（Function-Object Classes with State）**

### 14.8.1 Lambdas 是函数对象

**表示具有捕获值的 lambda 的类**

### 14.8.2 标准库中的函数对象

**使用标准库函数对象于通用算法**

### 14.8.3 可调用对象和 std::function

**不同的类型可以有相同的调用签名**

**标准库函数类型**

**重载的 Functions 和函数**

## 14.9 重载、转换和操作符

### 14.9.1 转换操作符

**定义一个具有转换操作符的类**

**注意：避免滥用转换函数**

**转换操作符可能会产生令人惊讶的结果**

**显式转换操作符**

**转换为 bool 值**

### 14.9.2 避免二义性转换

**参数匹配和相互转换**

**二义性和多重转换到内置类型**

**重载函数和转换构造函数**

**注意：转换和操作符**

**重载函数和用户定义的转换**

### 14.9.3 函数匹配和重载操作符

## 关键术语