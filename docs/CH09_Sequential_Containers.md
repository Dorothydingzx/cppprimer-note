本章内容是对第三章的一个扩展，并且是对标准库顺序容器的一个完整讨论。顺序容器（sequential containers）中的元素顺序就是其被添加到容器中的位置。标准库还定义了几个关联容器（associative containers），关联容器中元素顺序由每个元素的 key 决定。

容器类共享一些共同的接口，然后在对其进行自己的扩展。共同接口使得容器更容易学习；在一个容器上所学的东西可以运用到另外一个容器上，除了每种容器提供不同的性能和功能性上的抉择。

容器（container）可以容纳一系列特定类型的对象，顺序容器使得程序员可以控制元素被存储和访问的顺序。这些顺序不由元素的值决定，而是根据其对应的置入容器中的位置决定的。相反，有序和无序关联容器基于键值来存储器元素。

标准库还提供了三个容器适配器，适配器通过为容器类型的操作定义不同的接口来达到不同的语义。

以下内容是基于 §3.2 §3.3 §3.4 的内容的，在阅读下面的材料之前请先阅读这三节。

## 9.1 顺序容器概述

所有下面的容器都能够快速顺序访问其元素。它们之前的区别在于以下功能的性能取舍：

- 给容器添加和删除带来的消耗；
- 非顺序访问容器中的元素带来的消耗；

顺序容器列表如下：

- vector：灵活尺寸的数组，支持快速随机访问，除了在尾部插入或删除元素外会很慢；
- deque：双端队列，支持快速随机访问，支持首部和尾部的快速插入和删除；
- list：双链表，只支持双向顺序访问，在任何位置上都支持快速插入和删除；
- `forward_list`：单链表，只支持单一方向的顺序访问，在任何位置上都支持快速插入和删除；
- array：固定尺寸的数组，支持快速随机访问，但是不能添加和删除元素；
- sring：包含字符的特殊容器，类似于 vector，支持快速随机访问，以及在尾部的快速插入和删除；

除了 array 是固定尺寸（fixed-size）的容器，所有容器都提供了高效而灵活的内存管理。我们可以添加和删除元素，可以增加（growing）或缩减（shrinking）容器的大小。容器使用的存储元素的策略对于这些操作的性能有固有和重要的影响。在一些情况下甚至会影响一个特定的容器是否会提供特定的操作。

如：string 和 vector 将其元素放在连续的内存中，由于元素是连续的，能够快速按照其索引计算元素的地址。然而，在容器的中间添加或移除元素就是很耗时的操作了：所有位置在插入或删除之后的元素都必须移动以保持连续性。更甚者，添加元素有时会导致需要分配额外的内存，此时，所有元素都需要移动到新的内存中，并销毁原来使用的内存。

list 和 `forward_list` 被设计使得可以在容器的任何位置快速添加和删除，作为交换，这些类型不支持元素的随机访问：只能通过迭代的方式访问元素。并且相较于 vector, deque 和 array 消耗更多的内存。

deque 是一个更为复杂的数据结构。与 string 和 vector 一样，deque 支持快速随机访问（fast random access），并且在 deque 的中间添加和移除元素是很耗时的。然而，在 deque 的两端进行插入和删除则是很快速的操作，可以比得上在 `list` 或 `foward_list` 中添加元素。

`forwad_list` 和 array 是在新标准中添加进来的。array 是内置数组的一个更安全且易用的替代品。与内置数组一样，array 是固定尺寸的。因而，array 不支持添加和移除元素，或者改变容器的大小。`forward_list` 则是为了提供了性能上比得上最好的手写单链表。`forward_list` 没有提供 size 操作，这是由于存储和计算大小会导致其性能比不上手写的单链表。其它容器的 size 操作则保证是快速且是固定时间（constant-time）的操作。

由于移动操作的出现，现在的库容器的性能已经比之前的版本有了戏剧性的提升。库容器几乎肯定比绝大多数手写版本性能要好，现代 C++ 程序应该更多使用库容器而不是更基础的结构如内置数组。

**决定使用哪个顺序容器**

有一些选择使用哪个容器的首要原则：

- 除非了更好的理由，优先使用 vector；
- 如果程序有许多小的元素并且对空间消耗很敏感，不要使用 list 和 `forward_list`；
- 需要随机访问，使用 vector 或 deque；
- 需要在容器中间部分进行快速插入和删除，使用 list 或 `forward_list`；
- 如果程序需要是首部和尾部插入或删除元素，而不是中间部分，使用 deque；
- 如果程序在读取输入时需要在中间部分插入元素，而接下来则需要随机访问元素：
    - 先看是否真的需要在中间部分插入元素，通常更容易的做法是添加到 vector 中，然后调用库函数 sort 进行排序；
    - 如果确实需要在中间部分插入，考虑在输入阶段使用 list ，一旦完成了输入，将其复制到 vector 中去；

如果同时需要随机访问和在中间部分插入或删除元素？此时需要看占主要的操作是什么（更多的是插入或删除，还是更多的是访问），来决定使用哪种类型的容器。在这种情况下，使用多种容器进行性能测试是必不可少的。

最佳实践：如果你不知道该选择哪种容器，那就进使用 vector 和 list 共同的接口：迭代器而不是下标，避免随机访问元素。这样就可以在需要时很容易的替换。

## 9.2 容器库概述

容器类型上的操作组成了一种层级结构。一些操作是所有容器类型都提供的，其它一些则是顺序容器特有的，或者关联容器或无序容器特有的。而最后还有一些只有少部分的容器类型拥有。

在本节，我们将描述所有类型的容器都拥有的共同部分。§9.3 描述顺序容器特有的操作。¶11 描述关联容器特有的操作。

通常每个容器定义在与其名字相同的头文件中。deque 定义在 `<deque>` 头文件中，list 定义在 `<list>` 头文件中。容器都是类模板。与 vector 一样，使用时必须提供额外的信息来生成特定的容器类型。对于绝大部分容器来说，提供的是元素的类型，如：`list<Sales_data>` `deque<double>` 。

以下是所有容器共同的操作：

**类型别名**
- iterator ：每个容器类型自己的迭代器类型；
- `const_iterator` ：可以读取但不能修改元素的迭代器类型；
- `size_type` ：容器类型足够容纳最大的容器的尺寸的无符号整形值类型；
- `difference_type` ：两个迭代器之间的距离的有符号整形类型；
- `value_type` ：元素类型；
- reference ：元素的左值类型，与 `value_type&` 是同义词；
- `const_reference` 元素的 const 左值类型；

**赋值和 swap**
- `c1 = 2` 将 c1 中的元素替换为 c2 中的元素；
- `c1 = {a,b,c...}` 将 c1 中的元素替换为列表中的值（不适用于 array）；
- `a.swap(b)` 将 a、b 中的值进行交换；
- `swap(a, b)` 等于交换 `a.swap(b)`；

**Size**
- `c.size()` c 中元素个数（不适用于 `forward_list`）；
- `c.max_size()` c 所处的容器类型可以容纳的元素的最大数目；
- `c.empty()` 如果 c 有元素返回 false，否则返回 true；

**添加、移除元素（不适用于 array）**
Note：每个容器的接口参数不一样
- `c.insert(args)` 将 args 中的元素拷贝到 c 中；
- `c.emplace(inits)` 使用 inits 来构建 c 中的一个元素；
- `c.erase(args)` 从 c 中移除由 args 所表示的元素；
- `c.clear()` 移除 c 中的所有元素；返回 void；

**相等性和关系操作符**
- `==` `!=` 相等性操作符使用所有容器类型；
- `<` `<=` `>` `>=` 关系操作符（对于无序关联容器不适用）；

**获取迭代器**
- `c.begin()` `c.end()` 返回首元素和尾后元素（one past the last element）的迭代器；
- `c.cbegin()` `c.cend()` 返回 `const_iterator`；

**可反转的容器的额外成员（不适用于 `forward_list`）**
- `reverse_iterator` 以相反方向访问元素的迭代器；
- `const_reverse_iterator` 不能写元素的反向迭代器；
- `c.rbegin()` `c.rend()` 返回尾元素和首前元素（one past the first element）；
- `c.crbegin()` `c.crend()` 返回 `const_reverse_iterator`；

以下是定义和初始化容器的方式：

- `C c;` 默认构造函数，如果 C 是 array，那么 c 中的元素默认初始化的；否则 c 是空的；
- `C c1(c2);` c1 是 c2 的副本。c1 和 c2 必须是相同的类型（容器类型和元素类型都必须一样，对于 array 还必须有相同的 size）；
- `C c{a,b,c...}` `C c={a,b,c...}` c 是初始化列表元素的一个副本；列表中元素的类型必须与 C 的元素类型相互兼容，如果是 array，列表中的数目必须小于等于 array 中的大小，所有缺失的元素是值初始化的；
- `C c(b,e)` c 是迭代器 b 和 e 所表示的范围的元素的副本，其元素的类型必须与 c 中的元素类型互相兼容（不适用于 array）；

**以 size 初始化顺序容器（不适用于 array）**
- `C c(n);` c 具有 n 个值初始化元素，此构造函数是 explicit 的；
- `C c(n,t);` c 中具有 n 个值 t；

**容器可以容纳的元素类型**

几乎任何类型都可以作为顺序容器的元素类型。特别是可以定义容器的元素类型是另外一个容器。如：`vector<vector<string>> lines;` 在一些旧式的编译器中可能会要求相连的两个尖括号间用空格隔开。如：`vector<vector<string> >`。

尽管可以将几乎任何类型存储在容器中，一些容器操作对元素类型是有要求的。我们可以定义不支持某些操作要求的容器类型，但是想要使用这些操作就必须让元素类型满足这些操作的需求。

比如，接收一个 size 参数的顺序容器构造函数将使用元素类型的默认构造函数。一些类型是没有默认构造函数的，可以定义容器包含这种类型的对象，但是不能只使用元素数目去构建这样的容器。如：
````cpp
vector<noDefault> v1(10, init); // 正确：提供了元素初始值
vector<noDefault> v2(10); // 错误：必须提供元素的初始值
````

在接下来的介绍中会逐步描述其它操作对于容器元素类型的要求。

### 9.2.1 迭代器

与容器一样，迭代器（iterator）本身也是有共同的接口的。如果一个迭代器提供了某种操作，那么所有迭代器类型都提供的这种操作的行为都是一致的。如所有的标准容器都提供解引用操作符以访问容器元素，所有的标准库容器迭代器都提供自增运算符从一个元素移动到下一个元素。

`forward_list` 容器的迭代器不支持自减操作符，只有 string，vector，deque 和 array 支持迭代器的算术运算。

**迭代器范围**

迭代器范围的概念是标准库的一个基石。迭代器范围（iterator range）是由同一个容器中的一对迭代器来表示的，其中一个第一个元素，第二个指向最后的一个元素的下一个位置（one past the last element）。这两个迭代器通常用 begin 和 end 或者 first 和 last 来表示一个容器中的元素范围。

名字 last 带有一点误导的作用，第二个迭代器并不是指向最后一个元素，而是指向最后一个元素的下一个位置。元素范围包括 first 和一直到 last 之前的所有元素。这种元素范围成为左包含区间（left-inclusive interval），用数学表示就是 `[begin, end)` ，表示范围从 begin 开始，以 end 结束但是不包括 end。迭代器 begin 和 end 必须指向同一个容器。

end 一定不能指向 begin 之前的元素，只有这样才能通过自增 begin 迭代器而到达 end ，否则，所表示的范围就会无效。编译器并不能强制要求这种需求，只能有程序自己去保证这种约定。

**左包含范围的编程隐喻**

标准库使用左包含范围是由于这种范围有三个遍历的属性：

- 如果 begin 和 end 相等，那么范围是空的；
- 如果 begin 与 end 不相等，那么范围中至少有一个元素，并且 begin 表示范围内的第一个元素；
- 通过自增 begin 几次之后会达到 `begin == end`；

这几个属性使得我们可以这样书写循环，如：
````cpp
while (begin != end) {
    *begin = val;
    ++begin;
}
````

### 9.2.2 容器类型的成员

每个容器都定义了几个类型。如：`size_type` ，iterator 和 `const_iterator` 。绝大多数的容器还提供反向迭代器，反向迭代器的 `++` 将使得迭代器指向前一个元素，从而达到反向遍历容器元素的目的。

剩下的类型别名使得我们使用容器的元素类型时不需要真正知道其类型是什么。如果我们需要元素类型，我们只要使用 `value_type` 就可以，如果需要值的引用类型，就使用 reference 或者 `const_reference` 就可以。这些元素相关的类型别名在泛型编程中十分有用处。

使用这些类型需要用容器的类型加以限定，如：
````cpp
list<string>::iterator iter;
vector<int>::difference_type count;
````

### 9.2.3 begin 和 end 成员

begin 和 end 操作能够产生指向首元素和尾后元素的迭代器。它们通常用于表示容器中全部元素的迭代器范围。

标准库中有多个版本的 begin 和 end：r 版本返回反向迭代器，c 返回 const 的迭代器。如：
````cpp
list<string> a = {"Milton", "Shakespeare","Austen"};
auto it1 = a.begin();
auto it2 = a.rbegin();
auto it3 = a.cbegin();
auto it4 = a.crbegin();
````
没有以 c 开头的函数是重载的，在 const 成员返回的是 `const_iterator`，非 const 版本返回的 iterator 。这适用于 begin 、rbegin 、 end 和 rend。当在非 const 对象上调用时返回的是 iterator，只有当在 const 对象上调用时调用才是 const 版本。与指针和引用一样，可以将 iterator 转为 `const_iterator` ，但不能反着操作。

c 版本是新标准引入的，这样做是为了支持 auto 声明变量。在早期只能使用指明需要哪个类型如：
````cpp
list<string>::iterator it5 = a.begin();
list<string>::const_iterator it6 = a.begin();
auto it7 = a.begin();
auto it8 = a.cbegin();
````
如果使用 auto 那么 begin 和 end 返回的迭代器类型就由容器类型决定。使用 c 则可以不管是什么类型的容器都可以得到 `const_iterator`，当不需要写入时，使用 cbegin 和 cend。

### 9.2.4 定义和初始化容器

每个容器类型都定义了默认构造函数。除了 array ，其它容器的默认构造函数都创建一个空的容器。除了 array 之外，其它的容器可以接收一个 size 的参数，将初始化为有 size 个元素被值初始化的容器。

**初始化容器作为另外一个容器的副本**

有两种方式可以将一个容器初始化为别的容器的副本：调用拷贝构造函数或者（除 array 之外）拷贝由一对迭代器表示元素范围。

如果通过拷贝构造函数那么容器和元素的类型都必须一样。如果通过迭代器则没有这样的要求，只要元素类型之间是可以转换的。如：
````cpp
list<string> authors = {"Milton", "Shakespeare","Austen"};
vector<const char*> articles = {"a","an","the"};
list<string> list2(authors);
deque<string> authList(authors); // 错误：容器类型不匹配
vector<string> words(articles); // 错误：元素类型不匹配
// 将 const char* 转为 string
forward_list<string> words(articles.begin(), articles.end());
````
接收两个迭代器的构造函数使用它们来表示想要拷贝的元素范围。其中一个表示首元素另一个表示尾后元素。新的容器的大小与范围中的大小一致。新容器中的每个元素都是用范围内元素进行初始化的。

由于迭代器表示一个范围，可以使用构造函数拷贝一个容器的子序列。如 it 表示 authors 中的一个元素：
````cpp
deque<string> authList(authors.begin(), it);
````
以上将拷贝从 authors 的首元素直到 it 之前的所有元素。

**列表初始化**

在新标准下，可以使用列表初始化一个容器，如：
````cpp
list<string> authors = {"Milton","Shakespeare","Austen"};
vector<const char*> articles = {"a","an","the"};
````
列表初始化会指定容器中的每个元素的值。除了 array 之外，初始化列表同时暗含了容器的大小：容器大小与元素的初始化列表中的个数一样多。

**顺序容器指定大小的构造函数**

上面所介绍的所有构造函数同时适用于关联容器。除此之外顺序容器（除了 array 之外）还可以指定大小和可选的元素初始值。如果没有提供元素初始值，那么将创建一个值初始化的容器。如：
````cpp
vector<int> ivec(10, -1);
list<string> svec(10, "hi!");
forward_list<int> ivec(10);
deque<string> svec(10);
````
如果元素类型是内置类型或者具有默认构造函数的类类型，那么就可以使用接收一个大小的参数的构造函数来构建容器。如果元素类型没有默认构造函数，在初始化时必须同时显式提供元素初始值。

注意：指定大小的构造函数只适用于顺序容器；并不适用于关联容器。

**array 类是固定尺寸**

标准库 array 类型与内置数组一样，其尺寸是类型的一部分。当定义数组时除了指定元素类型时，还要指定大小。如：
````cpp
array<int, 42> arr1;
array<string, 10> arr2;
````
使用 array 类型同时需要指定元素类型和大小：
````cpp
array<int, 10>::size_type i;
array<int>::size_type j; // 错误：array<int> 不是一个类型
````
由于大小是 array 的一部分，array 不支持通常的容器构造函数。这些构造函数或隐式或显式决定了容器的大小。给 array 的构造函数传递表示大小的参数本身就是不必要且易错的。

array 的固定尺寸的属性同样影响其构造函数的行为。与其它容器不一样，其默认构造的 array 不是空的，而是所有的元素都是默认初始化的，这与内置数组的行为一致。如果想要使用列表初始化 array，提供的初始值必须小于等于 array 的大小。如果初始值更少的话，前面的部分将会被初始值初始化，后面的元素将被值初始化。在这两种情况下，如果元素类型是类类型，都必须要有默认构造函数。如：
````cpp
array<int, 10> ia1;
array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> ia3 = {42};
````
值得注意的是尽管我们不能拷贝或赋值内置数组，但是标准库 array 是可以拷贝和赋值的。如：
````cpp
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs; // 错误：内置数组不能拷贝和赋值
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits;
````
与任何容器一样，拷贝或赋值时类型必须是完全匹配的，对于 array 来说元素类型和尺寸都必须完全一样。

### 9.2.5 赋值和 swap

赋值相关的操作符作用域整个容器。其将左边容器的全部元素替换为右边容器中的元素的副本。如：
````cpp
c1 = c2; // 将 c1 的内容替换为 c2 中的元素的副本
c1 = {a,b,c}; // 将 c1 的内容替换为初始化列表中的元素的副本
````
当执行完赋值后，左右边的容器的内容就完全一样了。

与内置数组不一样，标准库 array 类型支持赋值。左右边的操作数必须是相同的类型：
````cpp
array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> a2 = {0};
a1 = a2; // 元素类型和大小都一样
a1 = {0}; // !!!错误：array 不支持初始值列表的赋值操作
````
由于初始值列表中的元素个数可能与 array 中的元素个数不一样，array 不支持用初始值列表进行赋值。基于同样的原因 array 同样不支持 assign 操作。

**容器的赋值操作**

- `c1 = c2` 将 c1 中的元素替换为 c2 中元素的副本。c1 和 c2 必须是相同类型；
- `c = {a,b,c...}` 将 c1 中元素替换为初始值列表中的元素的副本（不适用于数组）；
- `swap(c1, c2)` `c1.swap(c2)` 交换 c1 和 c2 中的元素。c1 和 c2 必须是相同的类型。swap 通常比 c2 到 c1 的赋值要*快很多*。

**assign 操作不适用于关联容器和 array**

- `seq.assign(b,e)` 将 seq 中的元素替换为由迭代器表示的范围中的值的副本，b 和 e 不能指向 seq 中的元素；
- `seq.assign(il)` 将 seq 中的元素替换为初始值列表 il 中的值的副本；
- `seq.assign(n,t)` 将 seq 中的元素替换为 n 个值 t 的副本；

赋值操作将使得左边容器中的迭代器、引用和指针失效，除了 string 之外，swap 之后却保持有效并且其所指向的容器被改变了（注：就是之前指向左边容器的迭代器，在 swap 之后指向右边容器中的元素了）。

**使用 assign（只有顺序容器支持）**

### 9.2.6 容器 size 操作
### 9.2.7 关系操作符
## 9.3 顺序容器操作
### 9.3.1 给顺序容器添加元素
### 9.3.2 访问元素
### 9.3.3 移除元素
### 9.3.4 特定于 `forward_list` 的操作
### 9.3.5 resize 容器大小
### 9.3.6 容器操作会使得迭代器失效
## 9.4 vector 如何增长
## 9.5 额外的 string 操作
### 9.5.1 构建 string 的其它方式
### 9.5.2 改变 string 的其它方式
### 9.5.3 string 搜索操作
### 9.5.4 compare 函数
### 9.5.5 数字转换
## 9.6 容器适配器
## 关键术语