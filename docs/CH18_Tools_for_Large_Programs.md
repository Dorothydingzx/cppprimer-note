C++ 可以处理的问题的范围十分广泛，从只需要一个程序员在几个小时内就能解决的小问题，到需要涉及到多个系统协作，有着百万行级别的代码量，并且需要几百个程序员在多年时间内参与的大问题（如：操作系统）。本书前面章节介绍的内容同时适合于所有这些跨度的问题。

语言还包括一些针对大的复杂系统而设计的特性。这些特性包括：异常处理（exception handling），名称空间（namespaces）和多重继承（multiple inheritance），这是本章将阐述的内容。

大型规模编程（Large-scale programming）对语言的要求要远高于小团队开发的系统对语言的要求。这些要求包括：

- 在独立开发的多个子系统间处理错误；
- 使用独立开发的库而不产生名称冲突；
- 对更加复杂的应用概念进行建模；

本章将讲述针对以上需求而设计的语言特性：异常、名称空间和多重继承。

## 18.1 异常处理

异常处理（Exception handling）允许独立开发的程序部分可以在运行时的错误进行通信（communicate）和处理（handle）。异常使得我们可以分离问题的发现部分和问题的处理部分。程序的一部分可以发现问题，然后将解决问题的工作传递给程序的另一部分。检测部分不需要知道处理部分的细节，反之亦然。

有效的使用异常处理需要理解当异常抛出时发生了什么，当捕获时发生了什么，以及用来传递错误的对象的含义。

### 18.1.1 抛出异常

在 C++ 中，异常是通过抛出（throwing）一个表达式来引发（raised）的。抛出的表达式的类型以及当前的调用链决定了哪个处理器（handler）将处理此异常。选中的处理器是调用链中匹配抛出对象类型的最近的代码。抛出对象的类型和内容允许抛出部分给处理部分提供出错信息。

当 throw 被执行时，throw 之后的语句是不会执行的。相反，控制（control）将从 throw 转移到对应的 catch 处。catch 子句可能在同一个函数中，也可能在直接或间接调用了发生异常的函数的函数中。控制从一个地方转到另一个地方的事实有两个重要的暗示：

- 调用链上的所有函数调用将永久退出；
- 当进入一个处理器时，调用链上创建的对象将被销毁；

**栈展开（Stack Unwinding）**

当异常抛出时，当前函数的执行被中止并开始搜索匹配的 catch 子句。如果 throw 出现在一个 try 块中，那么与之相对应的 catch 子句将首先被检查，如果找到了匹配的 catch 子句，异常就被此 catch 所处理。否则，如果 try 被嵌套在另外一个 try 中，那么将继续搜索外层的 catch 子句。如果没有任何 catch 匹配此异常，那么当前函数将退出，并且继续搜索发起调用的函数。这样一直向上，称为栈展开，直到找到一个匹配异常的 catch 子句，或者在没有找到任何匹配的 catch 子句时 main 函数自己退出。

假如找到了一个匹配的 catch 子句，将执行 catch 中的代码，当其完成后，将执行其后的第一条非 catch 子句代码。如果没有找到任何匹配的 catch 子句，程序将退出。异常是必须处理的，因为异常的目的就是阻止程序继续按常规执行，如果不处理异常则程序会隐式调用 terminate 库函数来终止程序的执行。

没有被捕获的异常将终止程序的执行。

**栈展开时对象将自动被销毁**

在栈展开时，调用链中的语句块将会永久退出，通常语句块中将创建本地对象，而本地对象则在语句块退出时销毁。栈展开执行相同的逻辑：当一个语句块在栈展开时退出，编译器保证其中创建的对象被适当的销毁。如果本地对象是类类型，对象的析构函数将执行，如果是内置类型，那么将不执行任何操作直接销毁。

异常可能发生在构造函数中，那么对象可能处于部分构建（partially constructed）状态。其中一些成员已经被初始化了，但是另外一些成员在异常发生时还没有初始化。即便处于部分构建状态，编译器将保证已经构建的成员将被销毁。

同样，异常可能发生在数组或容器元素的初始化过程中，编译器将保证在异常发生前构建的元素将被销毁。

**析构函数和异常**

析构函数总是执行，而函数中释放资源的代码可能会被跳过影响着我们如何组织程序。如果一个代码块分配了资源，但是异常发生在释放资源的代码之前，那么释放资源的代码将不会执行。另一方面，由类类型对象分配的资源肯定会被析构函数释放。通过使用类来控制资源的分配，我们可以保证资源总是被合理的释放，而不管函数是正常结束还是由异常导致结束。

栈展开时将执行析构函数影响着我们如何写析构函数。在栈展开时，异常已经引发但是还没有被处理。如果栈展开过程中又抛出一个新的异常，而没有在抛出的函数中捕获的话就会调用 terminate 函数。由于析构函数会在栈展开中调用，析构函数不应该抛出任何它自己不处理的异常。也意味着如果析构函数调用了可能抛出异常的函数，需要将其放在 try 块中，并将异常处理掉。

在现实中，由于析构函数只释放资源，它不太可能会抛出异常。所有的标准库中的类型都保证其析构函数不会抛出异常。

**注意：**在栈展开中，析构函数抛出了异常但是并没有处理，那么程序将退出。

**异常对象**

编译器使用抛出表达式来拷贝复制一个特殊对象称为异常对象（exception object）。所以抛出的对象必须是完全类型（complete type），如果对象是类类型，那么其必须具有可访问的析构函数和可访问的拷贝或移动构造函数。如果对象是数组或者函数类型，那么其将被转型为对应的指针类型。

异常对象驻留于编译器管理内存空间中，当任何 catch 子句被调用时，这个异常对象就会被访问，这个异常对象将在异常被处理之后被销毁。

抛出本地对象的指针是错误的用法，因为在栈展开时本地对象会被销毁。

### 18.1.2 捕捉异常

catch 子句中的异常声明（exception declaration）非常类似于只有一个参数的函数参数列表。当 catch 不需要访问抛出的异常对象时，异常声明中的名字可以省略。

异常声明中的类型决定了可以处理的异常，这个类型必须是完全类型，可以是左值引用但不能是右值引用。catch 子句非常类似于函数体。当进入 catch 子句时，异常声明中的参数将被初始化为异常对象，与函数参数一样，如果 catch 参数是非引用类型，那么 catch 参数是异常对象的拷贝；在 catch 中对参数做的任何改变都是针对本地拷贝而与异常对象本身没有任何关系。如果参数是引用类型，那么与任何别的引用参数是一样的，catch 参数是异常对象的另一个名字。对参数做的任何改变都会反映到异常对象上。

与函数参数一样，如果 catch 参数是基类类型，其可以被初始化为子类类型对象。如果 catch 参数是非引用类型，那么异常对象将被裁剪（sliced down），如果参数是基类类型的引用的话，那么参数将被绑定到异常对象上。

同样，异常声明的静态类型决定了 catch 可以执行的操作，如果 catch 参数是基类类型，那么 catch 就不能执行派生类类型的任何操作。

**最佳实践：**一个 catch 如果是处理通过继承关联起来的类型的异常对象时，应该将其声明为引用。

**查找一个匹配的处理器**

在查找匹配的 catch 时，找到的 catch 不需要是最匹配异常的那个，而是第一个匹配异常的那个。因而，在一串 catch 子句中，最具体的 catch 子句应该第一个出现。

由于 catch 子句是由其出现的顺序进行匹配的，使用具有继承关系的异常对象的程序必须将其 catch 子句进行排序使得处理派生类的处理器出现在处理基类的 catch 子句前。

异常匹配的规则比之函数参数匹配更加严格，绝大多数时候 catch 声明的异常类型必须与异常对象的类型完全一致，只有在极少数的情况下两者之间可以有差异：

- 从非 const 到 const 的转换是允许的，意味着抛出一个非 const 对象可以匹配一个声明为捕获 const 引用的 catch 子句；
- 从派生类到基类的转换是允许的；
- 数组可以转为其元素类型的指针；函数可以转为函数类型的指针；

其它的任何转型都是不允许的，特别指出的是不允许标准算术转型和类类型定义的转型。

**重新抛出（Rethrow）**

有时单个 catch 可能不能完全处理一个异常，它可以通过重新抛出将异常传递给上层的 catch 子句处理。重新抛出形如：`throw;` 就是 throw 后不跟随任何对象。空的 throw 只能出现在 catch 子句中，或者由 catch 调用的函数。如果一个空 throw 出现在非 catch 中，terminate 将被调用。

重新跑出异常不会指定对象，其当前的异常对象被传递到调用链的上层。通常 catch 会改变异常对象，这个改变后的异常对象只有被声明为引用时才会被上层 catch 子句观察到。

**捕获所有的处理器（The Catch-All Handler）**

可以通过 `catch(...)` 的方式来捕获所有的异常，这个称为 catch-all 处理器，这种处理器通常与重新抛出结合在一起，其做完任何可以做的本地工作然后重新抛出异常。如果将 `catch(...)` 与其它 catch 子句使用时应该放在最后的位置，其后的任何 catch 子句都不会被匹配到。

### 18.1.3 函数级 try 语句块和构造函数

异常可能会出现在处理构造函数的初始化时，在进入构造函数体之前需要先执行构造函数初始化，在构造函数体中的 catch 不能捕获有初始化器抛出的异常，这是由于构造函数体中的 try 块在异常抛出时还没有起作用。

为了捕获构造函数初始化器中的异常，必须书写构造函数为函数级 try 语句块（function try block）。这种语句块允许我们将一系列 catch 与构造函数的初始化阶段（或析构函数的析构阶段）和构造函数体（或析构函数体）关联起来。如：
````cpp
Blob(std::initializer_list<std::string> il) try :
    data(std::make_shared<std::vector<std::string>>(il)) {
        /* ... */
} catch (const std::bad_alloc &e) {
    /* handle_out_of_memory(e); */
}
````
此时 try 关键字出现在开始构造函数初始化列表的冒号之前，这也在开始构造函数体的大括号之前。与之关联的 catch 子句可以捕获成员初始化中或构造函数体中抛出的异常。

值得注意的是出现在构造函数参数本身时发生的异常不会被函数级 try 语句块捕获，只有开始构造函数的初始化列表后的异常才能被捕获。捕获这种异常的职责是调用表达式的，需要有调用者来处理。

**注意：**书写函数级 try 块是处理构造函数初始化列表中抛出异常的唯一方法。

### 18.1.4 noexcept 异常说明符

知道函数不会抛出任何异常对于程序员和编译器来说都是有好处的，程序员书写调用代码将更加简单，编译器则可以生成更加优化的机器码。

在新标准中，函数可以通过 noexcept 说明（noexcept specification），在函数参数列表后放置的 noexcept 关键字表示函数不会抛出异常：
````cpp
void recoup(int) noexcept; // won't throw
void alloc(int); // might throw
````
我们说 recoup 做了不抛出异常说明（nothrowing specification）。

noexcept 说明必须出现在所有的声明和定义处或者不出现在任何一个上。并且放在尾后返回类型之前。同样，noexcept 需要放在函数指针的声明或定义处。不过不需要放在类型别名或 typedef 处。在成员函数中，noexcept 说明符放在 const 或引用限定符之后，在 final 、override 或虚函数的 `= 0` 之前。

**违反异常说明**

需要指出的是编译器并不会在编译时对 noexcept 说明进行检查，甚至编译器都不能拒绝函数体内包含 throw 语句或者调用可能会抛出异常的函数的语句进行 noexcept 声明，不过某些编译器会对此进行警告。
````cpp
void f() noexcept
{
    throw exception();
}
````
如果 noexcept 函数抛出了异常，编译器将调用 terminate 函数来结束程序执行，这就强制保证了 noexcept 函数不会抛出异常。这里没有特别指定是否会进行栈展开。所有 noexcept 使用的场景应该是如下两个场景：1. 对于函数确实不会抛出异常有充分的自信；2. 对于函数抛出异常，不知如何进行处理；

指明函数不会抛出异常保证调用者不需要处理异常，要么函数真的不会抛出异常，要么程序就直接结束了。

**警告：**编译器通常不能也不会在编译期检查异常说明。

### 18.1.5 异常类层级

## 18.2 名称空间

### 18.2.1 名称空间定义
### 18.2.2 使用名称空间的成员
### 18.2.3 类、名称空间和作用域
### 18.2.4 重载和名称空间

## 18.3 多重继承和虚继承

### 18.3.1 多重继承
### 18.3.2 转换和多基类
### 18.3.3 多重继承下的类作用域
### 18.3.4 虚继承
### 18.3.5 构造函数和虚继承

## 关键术语
